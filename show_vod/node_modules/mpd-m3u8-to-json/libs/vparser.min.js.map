{"version":3,"sources":["webpack://VParser/webpack/universalModuleDefinition","webpack://VParser/webpack/bootstrap","webpack://VParser/./src/m3u8Parser.ts","webpack://VParser/./src/mpdParser.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","PREFIX_TAG_PATTERN","TAG_PAIR_SPLIT_PATTERN","formatNameToCamel","str","split","reduce","all","charAt","slice","toLowerCase","parseTag","tagStr","test","tagName","attr","matched","exec","attrStr","attrList","match","map","pairStr","attrPairStr","attrPairs","trim","replace","length","v","parseFloat","Number","isNaN","parseTagAttrPairs","filter","x","parseTagAttr","geneAbsUrl","url","base","shift","indexOf","push","join","m3u8Parser","text","m3u8Url","postHooks","error","msg","result","tagList","Boolean","master","levels","medias","duration","startSN","endSN","segments","live","len","cc","segCount","levelCount","keyIndex","tagInfo","segment","start","end","Array","isArray","sn","list","Error","mergeTags","e","message","PREFIX_LINE_PATTERN","TAG_ATTR_PATTERN","ATTR_PAIR_PATTERN","current","last","lastPre","stack","pop","attrs","prop","concat","mpdParser","tag","toUpperCase","formatName","ret"],"mappings":"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","file":"vparser.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VParser\"] = factory();\n\telse\n\t\troot[\"VParser\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","type AttrInfo = string | number | Array < string | number > | Object;\n\ntype TagInfo = {\n  [propName : string]: AttrInfo;\n  url?: string\n}\n\ntype Segment = {\n  start: number,\n  end: number,\n  duration: number,\n  url: string,\n  cc: number,\n  sn: number,\n  keyIndex?: number\n}\n\ntype LevelM3u8 = {\n  master: boolean,\n  m3u8Url: string,\n  duration: number,\n  segments: Array < Segment >,\n  startSN: number,\n  endSN: number,\n  live: boolean,\n  key?: Array < any >\n}\n\ntype Level = {\n  m3u8Url: string,\n  levelId: number,\n  brandwidth?: number,\n  codecs?: string,\n  audio?: string,\n  details?: LevelM3u8\n}\n\ntype MasterM3u8 = {\n  master: boolean,\n  m3u8Url: string,\n  medias: Array < any >,\n  levels: Array < Level >,\n  map?: {\n    url: string\n  }\n}\n\ntype M3u8JSON = MasterM3u8 | LevelM3u8 | {\n  error: 1,\n  msg: string\n};\n\ntype PostHooks = (x : TagInfo, y : M3u8JSON) => M3u8JSON\n\nconst PREFIX_TAG_PATTERN = /EXT(?:-X-)?([^:]+):?(.*)$/;\nconst TAG_PAIR_SPLIT_PATTERN = /([^,=\"]+)((=\"[^\"]+\")|(=[^,]+))*/g;\n\nfunction formatNameToCamel(str) {\n  return str\n    .split('-')\n    .reduce((all, c) => {\n      if (!all) {\n        all += c.toLowerCase();\n        return all;\n      }\n\n      all += c.charAt(0) + c\n        .slice(1)\n        .toLowerCase();\n\n      return all;\n    }, '')\n}\n\nfunction parseTag(tagStr : string) : TagInfo {\n  if(!(/^#EXT/.test(tagStr) || !(/^\\s*#/.test(tagStr)))) \n    return null;\n  \n  let tagName;\n  let attr;\n  let matched = PREFIX_TAG_PATTERN.exec(tagStr);\n\n  if (matched) {\n    tagName = formatNameToCamel(matched[1]);\n    attr = parseTagAttr(matched[2]);\n  } else {\n    tagName = 'url';\n    attr = tagStr;\n  }\n\n  return {[tagName]: attr}\n\n}\n\nfunction parseTagAttr(attrStr) : AttrInfo {\n  if(!attrStr) \n    return null;\n  \n  let attrList = attrStr\n    .match(TAG_PAIR_SPLIT_PATTERN)\n    .map(pairStr => parseTagAttrPairs(pairStr))\n\n    // tag with only one attr\n    if (attrList.length === 1) \n      return attrList[0]\n\n      // tag with multi not key=value attrs\n    if (attrList.filter(x => typeof x === 'object').length === 0) {\n      return attrList;\n    }\n\n    // tag with attrs that  format like key=value\n    return attrList\n    .reduce((all, c) => {\n      return {\n        ...all,\n        ...c\n      }\n    }, {})\n\n}\n\nfunction parseTagAttrPairs(attrPairStr) : AttrInfo {\n  /**\n   * 15.0\n   * METHOD=AES-128\n   * URI=\"https://priv.example.com/key.php?r=52\"\n   * URI=\"data:text/plain;base64,AAAASnBzc2gAAAAA7e+LqXnWSs6jyCfc1R0h7QAAACoSEJ7zznHou8m2HbJCHvWfK10SEJ7zznHou8m2HbJCHvWfK11I88aJmwY=\"\n   */\n\n  let attrPairs = attrPairStr\n    .trim()\n    .replace('=', '|')\n    .split('|');\n  if (attrPairs.length == 2) {\n    let key = formatNameToCamel(attrPairs[0])\n    return {\n      [key]: attrPairs[1].replace(/(\"|')/g, '')\n    }\n  }\n  let v = parseFloat(attrPairs[0]);\n  return Number.isNaN(v)\n    ? attrPairs[0]\n    : v;\n}\n\nfunction geneAbsUrl(url, base) {\n  if (/^https?/.test(url) || /^data:/.test(url) || /^sdk:/.test(url)) {\n    return url;\n  }\n\n  base = base\n    .split(\"/\")\n    .slice(0, -1)\n\n  url = url.split(\"/\");\n  while (url.length) {\n    let c = url.shift();\n    if (base.indexOf(c) == -1) {\n      base.push(c)\n    }\n  }\n  return base.join(\"/\");\n}\n\nfunction mergeTags(tagList, result, postHooks : PostHooks) {\n  let master = result.master;\n  let len = tagList.length;\n  let cc = 0;\n  let duration = 0;\n  let startSN = 0;\n  let segCount = 0;\n  let levelCount = 0;\n  let keyIndex = -1;\n\n  for (let i = 0; i < len; i++) {\n    let tagInfo = tagList[i];\n\n    for (let key in tagInfo) {\n      let v = tagInfo[key];\n      if (v && v['uri']) {\n        v['url'] = geneAbsUrl(v['uri'], result['m3u8Url']);\n      }\n      switch (key) {\n        case \"inf\":\n          // if contains human info?\n          let segment = {\n            start: duration,\n            end: duration + (Array.isArray(v)\n              ? v[0]\n              : v),\n            cc,\n            sn: startSN + segCount\n          };\n          if (keyIndex >= 0) {\n            segment['keyIndex'] = keyIndex;\n          }\n          segCount++;\n          duration = segment['end'];\n          result['segments'].push(segment);\n          break;\n        case \"start\":\n          duration = v;\n          break;\n        case \"discontinuity\":\n          cc++;\n          break;\n        case \"mediaSequence\":\n          startSN = v;\n          break;\n        case \"streamInf\":\n          levelCount++;\n          v['levelId'] = levelCount;\n          result['levels'].push(v);\n          break;\n        case \"media\":\n          result['medias'].push(v);\n          break;\n        case \"endlist\":\n          result['live'] = false;\n          break;\n        case \"key\":\n          keyIndex++;\n          if (result['key']) {\n            result['key'].push(v);\n          } else {\n            result['key'] = [v];\n          }\n          break;\n        case \"url\":\n          let list = master\n            ? result['levels']\n            : result['segments'];\n\n          if (!list.length) {\n            throw new Error('invalid m3u8');\n          }\n\n          if (master) {\n            list[levelCount - 1].url = geneAbsUrl(v, result['m3u8Url']);\n          } else {\n            list[segCount - 1].url = geneAbsUrl(v, result['m3u8Url'])\n          }\n          break;\n        default:\n          if (v) {\n            result[key] = v;\n          }\n      }\n    }\n    if (postHooks) {\n      result = postHooks(tagInfo, result)\n    }\n  }\n\n  if (!master) {\n    result['startSN'] = startSN;\n    result['endSN'] = startSN + segCount - 1;\n    result['duration'] = duration;\n  }\n\n  return result;\n\n}\n\nfunction m3u8Parser(text : string, m3u8Url : string, postHooks?: PostHooks) : M3u8JSON {\n  if(!text || !m3u8Url) {\n    return {error: 1, msg: \"invalid input\"}\n  }\n\n  const tagList = text\n    .split(\"\\n\")\n    .filter(Boolean)\n    .map((x) => parseTag(x.trim()))\n    .filter(Boolean);\n\n  if (!tagList.length) {\n    return {error: 1, msg: \"invalid m3u8\"}\n  }\n\n  const isMaster = tagList\n    .filter(x => !!x['streamInf'])\n    .length !== 0;\n\n  let result: M3u8JSON;\n\n  if (isMaster) {\n    result = {\n      master: true,\n      m3u8Url,\n      levels: [],\n      medias: []\n    }\n  } else {\n    result = {\n      master: false,\n      m3u8Url,\n      duration: 0,\n      startSN: 0,\n      endSN: 0,\n      segments: [],\n      live: true\n    }\n  }\n\n  try {\n    result = mergeTags(tagList, result, postHooks);\n  } catch (e) {\n    return {error: 1, msg: e.message}\n  }\n  return result;\n}\n\nexport default m3u8Parser;\n","type TagAttrs = {\n  [PropName: string]: any;\n};\n\ntype TagInfo = {\n  tagName?: string;\n  attrs?: TagAttrs;\n  closed?: boolean;\n};\n\ntype MPDJSON = {\n  [TagName: string]: any;\n};\n\ntype PostHooks = (tagName: string, attrs: TagAttrs) => TagAttrs;\n\nconst PREFIX_LINE_PATTERN = /\\s*(<\\/?[^>]+>)/;\nconst TAG_ATTR_PATTERN = /\\s*(?:<\\/?([^\\s>]+))?\\s*([^>]+)*(?:\\/?>)?/;\n\nconst ATTR_PAIR_PATTERN = /\\s*([^=]+)=\"([^\"]+)\"/g;\n\nconst formatName = tagName => {\n  if (!tagName) return '';\n\n  return tagName.split('_').reduce((all, c) => {\n    if (!all) {\n      all = c.charAt(0).toLowerCase() + c.slice(1);\n      return all;\n    }\n    all += c.charAt(0).toUpperCase() + c.slice(1);\n    return all;\n  }, '');\n};\n\nfunction parseTag(tagStr): TagInfo {\n  const matched = tagStr.match(TAG_ATTR_PATTERN);\n  const tag: TagInfo = {};\n\n  const tagName = formatName(matched && matched[1]);\n\n  // <TagName xx=xx xxx=xxx>\n  // <TagName xx=xxx xx=xxx />\n  if (matched && matched[1] && matched[2]) {\n    let ret;\n    let attrs = {};\n    while ((ret = ATTR_PAIR_PATTERN.exec(matched[2])) != null) {\n      attrs[ret[1]] = ret[2];\n    }\n    if (tagName === '?xml') return null;\n    tag['tagName'] = tagName;\n    tag['attrs'] = attrs;\n    tag['closed'] = /\\/$/.test(matched[2]); // is self closed?\n    return tag;\n  }\n\n  if (!matched) return null;\n\n  // </TagName>\n  if (/^<\\//.test(matched[0])) {\n    tag['tagName'] = tagName;\n    tag['closed'] = true;\n    return tag;\n  }\n\n  // <TagName>\n  if (/^</.test(matched[0])) {\n    tag['tagName'] = tagName;\n    tag['attrs'] = {};\n    return tag;\n  }\n\n  // pure value\n  tag['tagName'] = 'pureValue';\n  tag['attrs'] = {\n    value: matched[2]\n  };\n  tag['closed'] = true;\n  return tag;\n}\n\nfunction mergeTags(tagList, postHooks: PostHooks) {\n  const stack = [];\n  const len = tagList.length;\n  let current: TagInfo;\n  let last: TagInfo;\n  let lastPre: TagInfo;\n\n  for (let i = 0; i < len; i++) {\n    current = tagList[i];\n\n    // start tag\n    if (!current['closed']) {\n      stack.push(current);\n      continue;\n    }\n\n    last = stack.pop();\n\n    if (current['tagName'] === 'pureValue') {\n      last['attrs']\n        ? (last['attrs']['value'] = current['attrs']['value'])\n        : (last['attrs'] = current['attrs']);\n      stack.push(last);\n      continue;\n    }\n\n    if (last && last['tagName'] === current['tagName']) {\n      lastPre = stack.pop();\n    } else {\n      // self closed tag\n      lastPre = last;\n      last = current;\n    }\n\n    if (!lastPre) {\n      stack.push(last);\n      break;\n    }\n\n    let { tagName, attrs } = last;\n    const prop = lastPre['attrs'][tagName];\n\n    // custom handler\n    if (postHooks) {\n      attrs = postHooks(tagName, attrs);\n    }\n\n    if (prop) {\n      lastPre['attrs'][tagName] = Array.isArray(prop)\n        ? prop.concat(attrs)\n        : [prop, attrs];\n    } else {\n      lastPre['attrs'][tagName] = attrs;\n    }\n    stack.push(lastPre);\n  }\n\n  let v = stack[0];\n\n  if (!v) return null;\n\n  if (v['tagName'] != 'undefined') {\n    return {\n      [v['tagName']]: v['attrs']\n    };\n  }\n\n  return v['tagName'];\n}\n\nfunction mpdParser(text: string, postHooks?: PostHooks): MPDJSON {\n  if (!text) {\n    return { error: 1, msg: 'invalid input' };\n  }\n\n  try {\n    return mergeTags(\n      text\n        .split(PREFIX_LINE_PATTERN)\n        .filter(Boolean)\n        .map(x => parseTag(x))\n        .filter(Boolean),\n      postHooks\n    );\n  } catch (e) {\n    return { error: 1, msg: e.message };\n  }\n}\n\nexport default mpdParser;\n"],"sourceRoot":""}