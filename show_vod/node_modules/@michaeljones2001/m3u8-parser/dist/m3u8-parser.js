/*! @name @michaeljones2001/m3u8-parser @version 5.4.1 @license Apache-2.0 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('global/window')) :
	typeof define === 'function' && define.amd ? define(['exports', 'global/window'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.m3u8Parser = {}, global.window));
}(this, (function (exports, window$1) { 'use strict';

	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var window__default = /*#__PURE__*/_interopDefaultLegacy(window$1);

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, basedir, module) {
		return module = {
		  path: basedir,
		  exports: {},
		  require: function (path, base) {
	      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
	    }
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var setPrototypeOf = createCommonjsModule(function (module) {
	  function _setPrototypeOf(o, p) {
	    module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	      o.__proto__ = p;
	      return o;
	    };

	    module.exports["default"] = module.exports, module.exports.__esModule = true;
	    return _setPrototypeOf(o, p);
	  }

	  module.exports = _setPrototypeOf;
	  module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	var inheritsLoose = createCommonjsModule(function (module) {
	  function _inheritsLoose(subClass, superClass) {
	    subClass.prototype = Object.create(superClass.prototype);
	    subClass.prototype.constructor = subClass;
	    setPrototypeOf(subClass, superClass);
	  }

	  module.exports = _inheritsLoose;
	  module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	/**
	 * @file stream.js
	 */

	/**
	 * A lightweight readable stream implemention that handles event dispatching.
	 *
	 * @class Stream
	 */
	var Stream = /*#__PURE__*/function () {
	  function Stream() {
	    this.listeners = {};
	  }
	  /**
	   * Add a listener for a specified event type.
	   *
	   * @param {string} type the event name
	   * @param {Function} listener the callback to be invoked when an event of
	   * the specified type occurs
	   */


	  var _proto = Stream.prototype;

	  _proto.on = function on(type, listener) {
	    if (!this.listeners[type]) {
	      this.listeners[type] = [];
	    }

	    this.listeners[type].push(listener);
	  }
	  /**
	   * Remove a listener for a specified event type.
	   *
	   * @param {string} type the event name
	   * @param {Function} listener  a function previously registered for this
	   * type of event through `on`
	   * @return {boolean} if we could turn it off or not
	   */
	  ;

	  _proto.off = function off(type, listener) {
	    if (!this.listeners[type]) {
	      return false;
	    }

	    var index = this.listeners[type].indexOf(listener); // TODO: which is better?
	    // In Video.js we slice listener functions
	    // on trigger so that it does not mess up the order
	    // while we loop through.
	    //
	    // Here we slice on off so that the loop in trigger
	    // can continue using it's old reference to loop without
	    // messing up the order.

	    this.listeners[type] = this.listeners[type].slice(0);
	    this.listeners[type].splice(index, 1);
	    return index > -1;
	  }
	  /**
	   * Trigger an event of the specified type on this stream. Any additional
	   * arguments to this function are passed as parameters to event listeners.
	   *
	   * @param {string} type the event name
	   */
	  ;

	  _proto.trigger = function trigger(type) {
	    var callbacks = this.listeners[type];

	    if (!callbacks) {
	      return;
	    } // Slicing the arguments on every invocation of this method
	    // can add a significant amount of overhead. Avoid the
	    // intermediate object creation for the common case of a
	    // single callback argument


	    if (arguments.length === 2) {
	      var length = callbacks.length;

	      for (var i = 0; i < length; ++i) {
	        callbacks[i].call(this, arguments[1]);
	      }
	    } else {
	      var args = Array.prototype.slice.call(arguments, 1);
	      var _length = callbacks.length;

	      for (var _i = 0; _i < _length; ++_i) {
	        callbacks[_i].apply(this, args);
	      }
	    }
	  }
	  /**
	   * Destroys the stream and cleans up.
	   */
	  ;

	  _proto.dispose = function dispose() {
	    this.listeners = {};
	  }
	  /**
	   * Forwards all `data` events on this stream to the destination stream. The
	   * destination stream should provide a method `push` to receive the data
	   * events as they arrive.
	   *
	   * @param {Stream} destination the stream that will receive all `data` events
	   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options
	   */
	  ;

	  _proto.pipe = function pipe(destination) {
	    this.on('data', function (data) {
	      destination.push(data);
	    });
	  };

	  return Stream;
	}();

	/**
	 * A stream that buffers string input and generates a `data` event for each
	 * line.
	 *
	 * @class LineStream
	 * @extends Stream
	 */

	var LineStream = /*#__PURE__*/function (_Stream) {
	  inheritsLoose(LineStream, _Stream);

	  function LineStream() {
	    var _this;

	    _this = _Stream.call(this) || this;
	    _this.buffer = '';
	    return _this;
	  }
	  /**
	   * Add new data to be parsed.
	   *
	   * @param {string} data the text to process
	   */


	  var _proto = LineStream.prototype;

	  _proto.push = function push(data) {
	    var nextNewline;
	    this.buffer += data;
	    nextNewline = this.buffer.indexOf('\n');

	    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\n')) {
	      this.trigger('data', this.buffer.substring(0, nextNewline));
	      this.buffer = this.buffer.substring(nextNewline + 1);
	    }
	  };

	  return LineStream;
	}(Stream);

	var _extends_1 = createCommonjsModule(function (module) {
	  function _extends() {
	    module.exports = _extends = Object.assign || function (target) {
	      for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];

	        for (var key in source) {
	          if (Object.prototype.hasOwnProperty.call(source, key)) {
	            target[key] = source[key];
	          }
	        }
	      }

	      return target;
	    };

	    module.exports["default"] = module.exports, module.exports.__esModule = true;
	    return _extends.apply(this, arguments);
	  }

	  module.exports = _extends;
	  module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	var TAB = String.fromCharCode(0x09);

	var parseByterange = function parseByterange(byterangeString) {
	  // optionally match and capture 0+ digits before `@`
	  // optionally match and capture 0+ digits after `@`
	  var match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');
	  var result = {};

	  if (match[1]) {
	    result.length = parseInt(match[1], 10);
	  }

	  if (match[2]) {
	    result.offset = parseInt(match[2], 10);
	  }

	  return result;
	};
	/**
	 * "forgiving" attribute list psuedo-grammar:
	 * attributes -> keyvalue (',' keyvalue)*
	 * keyvalue   -> key '=' value
	 * key        -> [^=]*
	 * value      -> '"' [^"]* '"' | [^,]*
	 */


	var attributeSeparator = function attributeSeparator() {
	  var key = '[^=]*';
	  var value = '"[^"]*"|[^,]*';
	  var keyvalue = '(?:' + key + ')=(?:' + value + ')';
	  return new RegExp('(?:^|,)(' + keyvalue + ')');
	};
	/**
	 * Parse attributes from a line given the separator
	 *
	 * @param {string} attributes the attribute line to parse
	 */


	var parseAttributes = function parseAttributes(attributes) {
	  // split the string using attributes as the separator
	  var attrs = attributes.split(attributeSeparator());
	  var result = {};
	  var i = attrs.length;
	  var attr;

	  while (i--) {
	    // filter out unmatched portions of the string
	    if (attrs[i] === '') {
	      continue;
	    } // split the key and value


	    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value

	    attr[0] = attr[0].replace(/^\s+|\s+$/g, '');
	    attr[1] = attr[1].replace(/^\s+|\s+$/g, '');
	    attr[1] = attr[1].replace(/^['"](.*)['"]$/g, '$1');
	    result[attr[0]] = attr[1];
	  }

	  return result;
	};
	/**
	 * A line-level M3U8 parser event stream. It expects to receive input one
	 * line at a time and performs a context-free parse of its contents. A stream
	 * interpretation of a manifest can be useful if the manifest is expected to
	 * be too large to fit comfortably into memory or the entirety of the input
	 * is not immediately available. Otherwise, it's probably much easier to work
	 * with a regular `Parser` object.
	 *
	 * Produces `data` events with an object that captures the parser's
	 * interpretation of the input. That object has a property `tag` that is one
	 * of `uri`, `comment`, or `tag`. URIs only have a single additional
	 * property, `line`, which captures the entirety of the input without
	 * interpretation. Comments similarly have a single additional property
	 * `text` which is the input without the leading `#`.
	 *
	 * Tags always have a property `tagType` which is the lower-cased version of
	 * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,
	 * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized
	 * tags are given the tag type `unknown` and a single additional property
	 * `data` with the remainder of the input.
	 *
	 * @class ParseStream
	 * @extends Stream
	 */


	var ParseStream = /*#__PURE__*/function (_Stream) {
	  inheritsLoose(ParseStream, _Stream);

	  function ParseStream() {
	    var _this;

	    _this = _Stream.call(this) || this;
	    _this.customParsers = [];
	    _this.tagMappers = [];
	    return _this;
	  } // TODO: add support for #EXT-X-INDEPENDENT-SEGMENTS

	  /**
	   * Parses an additional line of input.
	   *
	   * @param {string} line a single line of an M3U8 file to parse
	   */


	  var _proto = ParseStream.prototype;

	  _proto.push = function push(line) {
	    var _this2 = this;

	    var match;
	    var event; // strip whitespace

	    line = line.trim();

	    if (line.length === 0) {
	      // ignore empty lines
	      return;
	    } // URIs


	    if (line[0] !== '#') {
	      this.trigger('data', {
	        type: 'uri',
	        uri: line
	      });
	      return;
	    } // map tags


	    var newLines = this.tagMappers.reduce(function (acc, mapper) {
	      var mappedLine = mapper(line); // skip if unchanged

	      if (mappedLine === line) {
	        return acc;
	      }

	      return acc.concat([mappedLine]);
	    }, [line]);
	    newLines.forEach(function (newLine) {
	      for (var i = 0; i < _this2.customParsers.length; i++) {
	        if (_this2.customParsers[i].call(_this2, newLine)) {
	          return;
	        }
	      } // Comments


	      if (newLine.indexOf('#EXT') !== 0) {
	        _this2.trigger('data', {
	          type: 'comment',
	          text: newLine.slice(1)
	        });

	        return;
	      } // strip off any carriage returns here so the regex matching
	      // doesn't have to account for them.


	      newLine = newLine.replace('\r', ''); // Tags

	      match = /^#EXTM3U/.exec(newLine);

	      if (match) {
	        _this2.trigger('data', {
	          type: 'tag',
	          tagType: 'm3u'
	        });

	        return;
	      }

	      match = /^#EXTINF:?([0-9\.]*)?,?(.*)?$/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'inf'
	        };

	        if (match[1]) {
	          event.duration = parseFloat(match[1]);
	        }

	        if (match[2]) {
	          event.title = match[2];
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'targetduration'
	        };

	        if (match[1]) {
	          event.duration = parseInt(match[1], 10);
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'version'
	        };

	        if (match[1]) {
	          event.version = parseInt(match[1], 10);
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'media-sequence'
	        };

	        if (match[1]) {
	          event.number = parseInt(match[1], 10);
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'discontinuity-sequence'
	        };

	        if (match[1]) {
	          event.number = parseInt(match[1], 10);
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'playlist-type'
	        };

	        if (match[1]) {
	          event.playlistType = match[1];
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-BYTERANGE:?(.*)?$/.exec(newLine);

	      if (match) {
	        event = _extends_1(parseByterange(match[1]), {
	          type: 'tag',
	          tagType: 'byterange'
	        });

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'allow-cache'
	        };

	        if (match[1]) {
	          event.allowed = !/NO/.test(match[1]);
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-MAP:?(.*)$/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'map'
	        };

	        if (match[1]) {
	          var attributes = parseAttributes(match[1]);

	          if (attributes.URI) {
	            event.uri = attributes.URI;
	          }

	          if (attributes.BYTERANGE) {
	            event.byterange = parseByterange(attributes.BYTERANGE);
	          }
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'stream-inf'
	        };

	        if (match[1]) {
	          event.attributes = parseAttributes(match[1]);

	          if (event.attributes.RESOLUTION) {
	            var split = event.attributes.RESOLUTION.split('x');
	            var resolution = {};

	            if (split[0]) {
	              resolution.width = parseInt(split[0], 10);
	            }

	            if (split[1]) {
	              resolution.height = parseInt(split[1], 10);
	            }

	            event.attributes.RESOLUTION = resolution;
	          }

	          if (event.attributes.BANDWIDTH) {
	            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);
	          }

	          if (event.attributes['PROGRAM-ID']) {
	            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);
	          }
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'media'
	        };

	        if (match[1]) {
	          event.attributes = parseAttributes(match[1]);
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-ENDLIST/.exec(newLine);

	      if (match) {
	        _this2.trigger('data', {
	          type: 'tag',
	          tagType: 'endlist'
	        });

	        return;
	      }

	      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);

	      if (match) {
	        _this2.trigger('data', {
	          type: 'tag',
	          tagType: 'discontinuity'
	        });

	        return;
	      }

	      match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'program-date-time'
	        };

	        if (match[1]) {
	          event.dateTimeString = match[1];
	          event.dateTimeObject = new Date(match[1]);
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-KEY:?(.*)$/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'key'
	        };

	        if (match[1]) {
	          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array

	          if (event.attributes.IV) {
	            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {
	              event.attributes.IV = event.attributes.IV.substring(2);
	            }

	            event.attributes.IV = event.attributes.IV.match(/.{8}/g);
	            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);
	            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);
	            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);
	            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);
	            event.attributes.IV = new Uint32Array(event.attributes.IV);
	          }
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-START:?(.*)$/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'start'
	        };

	        if (match[1]) {
	          event.attributes = parseAttributes(match[1]);
	          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);
	          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'cue-out-cont'
	        };

	        if (match[1]) {
	          event.data = match[1];
	        } else {
	          event.data = '';
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'cue-out'
	        };

	        if (match[1]) {
	          event.data = match[1];
	        } else {
	          event.data = '';
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'cue-in'
	        };

	        if (match[1]) {
	          event.data = match[1];
	        } else {
	          event.data = '';
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);

	      if (match && match[1]) {
	        event = {
	          type: 'tag',
	          tagType: 'skip'
	        };
	        event.attributes = parseAttributes(match[1]);

	        if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {
	          event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);
	        }

	        if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {
	          event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-PART:(.*)$/.exec(newLine);

	      if (match && match[1]) {
	        event = {
	          type: 'tag',
	          tagType: 'part'
	        };
	        event.attributes = parseAttributes(match[1]);
	        ['DURATION'].forEach(function (key) {
	          if (event.attributes.hasOwnProperty(key)) {
	            event.attributes[key] = parseFloat(event.attributes[key]);
	          }
	        });
	        ['INDEPENDENT', 'GAP'].forEach(function (key) {
	          if (event.attributes.hasOwnProperty(key)) {
	            event.attributes[key] = /YES/.test(event.attributes[key]);
	          }
	        });

	        if (event.attributes.hasOwnProperty('BYTERANGE')) {
	          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);
	        }

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);

	      if (match && match[1]) {
	        event = {
	          type: 'tag',
	          tagType: 'server-control'
	        };
	        event.attributes = parseAttributes(match[1]);
	        ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {
	          if (event.attributes.hasOwnProperty(key)) {
	            event.attributes[key] = parseFloat(event.attributes[key]);
	          }
	        });
	        ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {
	          if (event.attributes.hasOwnProperty(key)) {
	            event.attributes[key] = /YES/.test(event.attributes[key]);
	          }
	        });

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);

	      if (match && match[1]) {
	        event = {
	          type: 'tag',
	          tagType: 'part-inf'
	        };
	        event.attributes = parseAttributes(match[1]);
	        ['PART-TARGET'].forEach(function (key) {
	          if (event.attributes.hasOwnProperty(key)) {
	            event.attributes[key] = parseFloat(event.attributes[key]);
	          }
	        });

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);

	      if (match && match[1]) {
	        event = {
	          type: 'tag',
	          tagType: 'preload-hint'
	        };
	        event.attributes = parseAttributes(match[1]);
	        ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {
	          if (event.attributes.hasOwnProperty(key)) {
	            event.attributes[key] = parseInt(event.attributes[key], 10);
	            var subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';
	            event.attributes.byterange = event.attributes.byterange || {};
	            event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.

	            delete event.attributes[key];
	          }
	        });

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-INDEPENDENT-SEGMENTS$/.exec(newLine);

	      if (match) {
	        event = {
	          type: 'tag',
	          tagType: 'independent-segments'
	        };

	        _this2.trigger('data', event);

	        return;
	      }

	      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);

	      if (match && match[1]) {
	        event = {
	          type: 'tag',
	          tagType: 'rendition-report'
	        };
	        event.attributes = parseAttributes(match[1]);
	        ['LAST-MSN', 'LAST-PART'].forEach(function (key) {
	          if (event.attributes.hasOwnProperty(key)) {
	            event.attributes[key] = parseInt(event.attributes[key], 10);
	          }
	        });

	        _this2.trigger('data', event);

	        return;
	      } // unknown tag type


	      _this2.trigger('data', {
	        type: 'tag',
	        data: newLine.slice(4)
	      });
	    });
	  }
	  /**
	   * Add a parser for custom headers
	   *
	   * @param {Object}   options              a map of options for the added parser
	   * @param {RegExp}   options.expression   a regular expression to match the custom header
	   * @param {string}   options.customType   the custom type to register to the output
	   * @param {Function} [options.dataParser] function to parse the line into an object
	   * @param {boolean}  [options.segment]    should tag data be attached to the segment object
	   */
	  ;

	  _proto.addParser = function addParser(_ref) {
	    var _this3 = this;

	    var expression = _ref.expression,
	        customType = _ref.customType,
	        dataParser = _ref.dataParser,
	        segment = _ref.segment;

	    if (typeof dataParser !== 'function') {
	      dataParser = function dataParser(line) {
	        return line;
	      };
	    }

	    this.customParsers.push(function (line) {
	      var match = expression.exec(line);

	      if (match) {
	        _this3.trigger('data', {
	          type: 'custom',
	          data: dataParser(line),
	          customType: customType,
	          segment: segment
	        });

	        return true;
	      }
	    });
	  }
	  /**
	   * Add a custom header mapper
	   *
	   * @param {Object}   options
	   * @param {RegExp}   options.expression   a regular expression to match the custom header
	   * @param {Function} options.map          function to translate tag into a different tag
	   */
	  ;

	  _proto.addTagMapper = function addTagMapper(_ref2) {
	    var expression = _ref2.expression,
	        map = _ref2.map;

	    var mapFn = function mapFn(line) {
	      if (expression.test(line)) {
	        return map(line);
	      }

	      return line;
	    };

	    this.tagMappers.push(mapFn);
	  };

	  return ParseStream;
	}(Stream);

	var assertThisInitialized = createCommonjsModule(function (module) {
	  function _assertThisInitialized(self) {
	    if (self === void 0) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return self;
	  }

	  module.exports = _assertThisInitialized;
	  module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	var atob = function atob(s) {
	  return window__default['default'].atob ? window__default['default'].atob(s) : Buffer.from(s, 'base64').toString('binary');
	};

	function decodeB64ToUint8Array(b64Text) {
	  var decodedString = atob(b64Text);
	  var array = new Uint8Array(decodedString.length);

	  for (var i = 0; i < decodedString.length; i++) {
	    array[i] = decodedString.charCodeAt(i);
	  }

	  return array;
	}

	var lodash_isequal = createCommonjsModule(function (module, exports) {
	  /**
	   * Lodash (Custom Build) <https://lodash.com/>
	   * Build: `lodash modularize exports="npm" -o ./`
	   * Copyright JS Foundation and other contributors <https://js.foundation/>
	   * Released under MIT license <https://lodash.com/license>
	   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	   */

	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;
	  /** Used to stand-in for `undefined` hash values. */

	  var HASH_UNDEFINED = '__lodash_hash_undefined__';
	  /** Used to compose bitmasks for value comparisons. */

	  var COMPARE_PARTIAL_FLAG = 1,
	      COMPARE_UNORDERED_FLAG = 2;
	  /** Used as references for various `Number` constants. */

	  var MAX_SAFE_INTEGER = 9007199254740991;
	  /** `Object#toString` result references. */

	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      asyncTag = '[object AsyncFunction]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      genTag = '[object GeneratorFunction]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      nullTag = '[object Null]',
	      objectTag = '[object Object]',
	      promiseTag = '[object Promise]',
	      proxyTag = '[object Proxy]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      symbolTag = '[object Symbol]',
	      undefinedTag = '[object Undefined]',
	      weakMapTag = '[object WeakMap]';
	  var arrayBufferTag = '[object ArrayBuffer]',
	      dataViewTag = '[object DataView]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';
	  /**
	   * Used to match `RegExp`
	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	   */

	  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	  /** Used to detect host constructors (Safari). */

	  var reIsHostCtor = /^\[object .+?Constructor\]$/;
	  /** Used to detect unsigned integer values. */

	  var reIsUint = /^(?:0|[1-9]\d*)$/;
	  /** Used to identify `toStringTag` values of typed arrays. */

	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
	  /** Detect free variable `global` from Node.js. */

	  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
	  /** Detect free variable `self`. */

	  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	  /** Used as a reference to the global object. */

	  var root = freeGlobal || freeSelf || Function('return this')();
	  /** Detect free variable `exports`. */

	  var freeExports = exports && !exports.nodeType && exports;
	  /** Detect free variable `module`. */

	  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
	  /** Detect the popular CommonJS extension `module.exports`. */

	  var moduleExports = freeModule && freeModule.exports === freeExports;
	  /** Detect free variable `process` from Node.js. */

	  var freeProcess = moduleExports && freeGlobal.process;
	  /** Used to access faster Node.js helpers. */

	  var nodeUtil = function () {
	    try {
	      return freeProcess && freeProcess.binding && freeProcess.binding('util');
	    } catch (e) {}
	  }();
	  /* Node.js helper references. */


	  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	  /**
	   * A specialized version of `_.filter` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {Array} Returns the new filtered array.
	   */

	  function arrayFilter(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        resIndex = 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];

	      if (predicate(value, index, array)) {
	        result[resIndex++] = value;
	      }
	    }

	    return result;
	  }
	  /**
	   * Appends the elements of `values` to `array`.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {Array} values The values to append.
	   * @returns {Array} Returns `array`.
	   */


	  function arrayPush(array, values) {
	    var index = -1,
	        length = values.length,
	        offset = array.length;

	    while (++index < length) {
	      array[offset + index] = values[index];
	    }

	    return array;
	  }
	  /**
	   * A specialized version of `_.some` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if any element passes the predicate check,
	   *  else `false`.
	   */


	  function arraySome(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (predicate(array[index], index, array)) {
	        return true;
	      }
	    }

	    return false;
	  }
	  /**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */


	  function baseTimes(n, iteratee) {
	    var index = -1,
	        result = Array(n);

	    while (++index < n) {
	      result[index] = iteratee(index);
	    }

	    return result;
	  }
	  /**
	   * The base implementation of `_.unary` without support for storing metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new capped function.
	   */


	  function baseUnary(func) {
	    return function (value) {
	      return func(value);
	    };
	  }
	  /**
	   * Checks if a `cache` value for `key` exists.
	   *
	   * @private
	   * @param {Object} cache The cache to query.
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */


	  function cacheHas(cache, key) {
	    return cache.has(key);
	  }
	  /**
	   * Gets the value at `key` of `object`.
	   *
	   * @private
	   * @param {Object} [object] The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */


	  function getValue(object, key) {
	    return object == null ? undefined : object[key];
	  }
	  /**
	   * Converts `map` to its key-value pairs.
	   *
	   * @private
	   * @param {Object} map The map to convert.
	   * @returns {Array} Returns the key-value pairs.
	   */


	  function mapToArray(map) {
	    var index = -1,
	        result = Array(map.size);
	    map.forEach(function (value, key) {
	      result[++index] = [key, value];
	    });
	    return result;
	  }
	  /**
	   * Creates a unary function that invokes `func` with its argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */


	  function overArg(func, transform) {
	    return function (arg) {
	      return func(transform(arg));
	    };
	  }
	  /**
	   * Converts `set` to an array of its values.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the values.
	   */


	  function setToArray(set) {
	    var index = -1,
	        result = Array(set.size);
	    set.forEach(function (value) {
	      result[++index] = value;
	    });
	    return result;
	  }
	  /** Used for built-in method references. */


	  var arrayProto = Array.prototype,
	      funcProto = Function.prototype,
	      objectProto = Object.prototype;
	  /** Used to detect overreaching core-js shims. */

	  var coreJsData = root['__core-js_shared__'];
	  /** Used to resolve the decompiled source of functions. */

	  var funcToString = funcProto.toString;
	  /** Used to check objects for own properties. */

	  var hasOwnProperty = objectProto.hasOwnProperty;
	  /** Used to detect methods masquerading as native. */

	  var maskSrcKey = function () {
	    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	    return uid ? 'Symbol(src)_1.' + uid : '';
	  }();
	  /**
	   * Used to resolve the
	   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	   * of values.
	   */


	  var nativeObjectToString = objectProto.toString;
	  /** Used to detect if a method is native. */

	  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  /** Built-in value references. */

	  var Buffer = moduleExports ? root.Buffer : undefined,
	      Symbol = root.Symbol,
	      Uint8Array = root.Uint8Array,
	      propertyIsEnumerable = objectProto.propertyIsEnumerable,
	      splice = arrayProto.splice,
	      symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	  /* Built-in method references for those with the same name as other `lodash` methods. */

	  var nativeGetSymbols = Object.getOwnPropertySymbols,
	      nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	      nativeKeys = overArg(Object.keys, Object);
	  /* Built-in method references that are verified to be native. */

	  var DataView = getNative(root, 'DataView'),
	      Map = getNative(root, 'Map'),
	      Promise = getNative(root, 'Promise'),
	      Set = getNative(root, 'Set'),
	      WeakMap = getNative(root, 'WeakMap'),
	      nativeCreate = getNative(Object, 'create');
	  /** Used to detect maps, sets, and weakmaps. */

	  var dataViewCtorString = toSource(DataView),
	      mapCtorString = toSource(Map),
	      promiseCtorString = toSource(Promise),
	      setCtorString = toSource(Set),
	      weakMapCtorString = toSource(WeakMap);
	  /** Used to convert symbols to primitives and strings. */

	  var symbolProto = Symbol ? Symbol.prototype : undefined,
	      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
	  /**
	   * Creates a hash object.
	   *
	   * @private
	   * @constructor
	   * @param {Array} [entries] The key-value pairs to cache.
	   */

	  function Hash(entries) {
	    var index = -1,
	        length = entries == null ? 0 : entries.length;
	    this.clear();

	    while (++index < length) {
	      var entry = entries[index];
	      this.set(entry[0], entry[1]);
	    }
	  }
	  /**
	   * Removes all key-value entries from the hash.
	   *
	   * @private
	   * @name clear
	   * @memberOf Hash
	   */


	  function hashClear() {
	    this.__data__ = nativeCreate ? nativeCreate(null) : {};
	    this.size = 0;
	  }
	  /**
	   * Removes `key` and its value from the hash.
	   *
	   * @private
	   * @name delete
	   * @memberOf Hash
	   * @param {Object} hash The hash to modify.
	   * @param {string} key The key of the value to remove.
	   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	   */


	  function hashDelete(key) {
	    var result = this.has(key) && delete this.__data__[key];
	    this.size -= result ? 1 : 0;
	    return result;
	  }
	  /**
	   * Gets the hash value for `key`.
	   *
	   * @private
	   * @name get
	   * @memberOf Hash
	   * @param {string} key The key of the value to get.
	   * @returns {*} Returns the entry value.
	   */


	  function hashGet(key) {
	    var data = this.__data__;

	    if (nativeCreate) {
	      var result = data[key];
	      return result === HASH_UNDEFINED ? undefined : result;
	    }

	    return hasOwnProperty.call(data, key) ? data[key] : undefined;
	  }
	  /**
	   * Checks if a hash value for `key` exists.
	   *
	   * @private
	   * @name has
	   * @memberOf Hash
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */


	  function hashHas(key) {
	    var data = this.__data__;
	    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	  }
	  /**
	   * Sets the hash `key` to `value`.
	   *
	   * @private
	   * @name set
	   * @memberOf Hash
	   * @param {string} key The key of the value to set.
	   * @param {*} value The value to set.
	   * @returns {Object} Returns the hash instance.
	   */


	  function hashSet(key, value) {
	    var data = this.__data__;
	    this.size += this.has(key) ? 0 : 1;
	    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
	    return this;
	  } // Add methods to `Hash`.


	  Hash.prototype.clear = hashClear;
	  Hash.prototype['delete'] = hashDelete;
	  Hash.prototype.get = hashGet;
	  Hash.prototype.has = hashHas;
	  Hash.prototype.set = hashSet;
	  /**
	   * Creates an list cache object.
	   *
	   * @private
	   * @constructor
	   * @param {Array} [entries] The key-value pairs to cache.
	   */

	  function ListCache(entries) {
	    var index = -1,
	        length = entries == null ? 0 : entries.length;
	    this.clear();

	    while (++index < length) {
	      var entry = entries[index];
	      this.set(entry[0], entry[1]);
	    }
	  }
	  /**
	   * Removes all key-value entries from the list cache.
	   *
	   * @private
	   * @name clear
	   * @memberOf ListCache
	   */


	  function listCacheClear() {
	    this.__data__ = [];
	    this.size = 0;
	  }
	  /**
	   * Removes `key` and its value from the list cache.
	   *
	   * @private
	   * @name delete
	   * @memberOf ListCache
	   * @param {string} key The key of the value to remove.
	   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	   */


	  function listCacheDelete(key) {
	    var data = this.__data__,
	        index = assocIndexOf(data, key);

	    if (index < 0) {
	      return false;
	    }

	    var lastIndex = data.length - 1;

	    if (index == lastIndex) {
	      data.pop();
	    } else {
	      splice.call(data, index, 1);
	    }

	    --this.size;
	    return true;
	  }
	  /**
	   * Gets the list cache value for `key`.
	   *
	   * @private
	   * @name get
	   * @memberOf ListCache
	   * @param {string} key The key of the value to get.
	   * @returns {*} Returns the entry value.
	   */


	  function listCacheGet(key) {
	    var data = this.__data__,
	        index = assocIndexOf(data, key);
	    return index < 0 ? undefined : data[index][1];
	  }
	  /**
	   * Checks if a list cache value for `key` exists.
	   *
	   * @private
	   * @name has
	   * @memberOf ListCache
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */


	  function listCacheHas(key) {
	    return assocIndexOf(this.__data__, key) > -1;
	  }
	  /**
	   * Sets the list cache `key` to `value`.
	   *
	   * @private
	   * @name set
	   * @memberOf ListCache
	   * @param {string} key The key of the value to set.
	   * @param {*} value The value to set.
	   * @returns {Object} Returns the list cache instance.
	   */


	  function listCacheSet(key, value) {
	    var data = this.__data__,
	        index = assocIndexOf(data, key);

	    if (index < 0) {
	      ++this.size;
	      data.push([key, value]);
	    } else {
	      data[index][1] = value;
	    }

	    return this;
	  } // Add methods to `ListCache`.


	  ListCache.prototype.clear = listCacheClear;
	  ListCache.prototype['delete'] = listCacheDelete;
	  ListCache.prototype.get = listCacheGet;
	  ListCache.prototype.has = listCacheHas;
	  ListCache.prototype.set = listCacheSet;
	  /**
	   * Creates a map cache object to store key-value pairs.
	   *
	   * @private
	   * @constructor
	   * @param {Array} [entries] The key-value pairs to cache.
	   */

	  function MapCache(entries) {
	    var index = -1,
	        length = entries == null ? 0 : entries.length;
	    this.clear();

	    while (++index < length) {
	      var entry = entries[index];
	      this.set(entry[0], entry[1]);
	    }
	  }
	  /**
	   * Removes all key-value entries from the map.
	   *
	   * @private
	   * @name clear
	   * @memberOf MapCache
	   */


	  function mapCacheClear() {
	    this.size = 0;
	    this.__data__ = {
	      'hash': new Hash(),
	      'map': new (Map || ListCache)(),
	      'string': new Hash()
	    };
	  }
	  /**
	   * Removes `key` and its value from the map.
	   *
	   * @private
	   * @name delete
	   * @memberOf MapCache
	   * @param {string} key The key of the value to remove.
	   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	   */


	  function mapCacheDelete(key) {
	    var result = getMapData(this, key)['delete'](key);
	    this.size -= result ? 1 : 0;
	    return result;
	  }
	  /**
	   * Gets the map value for `key`.
	   *
	   * @private
	   * @name get
	   * @memberOf MapCache
	   * @param {string} key The key of the value to get.
	   * @returns {*} Returns the entry value.
	   */


	  function mapCacheGet(key) {
	    return getMapData(this, key).get(key);
	  }
	  /**
	   * Checks if a map value for `key` exists.
	   *
	   * @private
	   * @name has
	   * @memberOf MapCache
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */


	  function mapCacheHas(key) {
	    return getMapData(this, key).has(key);
	  }
	  /**
	   * Sets the map `key` to `value`.
	   *
	   * @private
	   * @name set
	   * @memberOf MapCache
	   * @param {string} key The key of the value to set.
	   * @param {*} value The value to set.
	   * @returns {Object} Returns the map cache instance.
	   */


	  function mapCacheSet(key, value) {
	    var data = getMapData(this, key),
	        size = data.size;
	    data.set(key, value);
	    this.size += data.size == size ? 0 : 1;
	    return this;
	  } // Add methods to `MapCache`.


	  MapCache.prototype.clear = mapCacheClear;
	  MapCache.prototype['delete'] = mapCacheDelete;
	  MapCache.prototype.get = mapCacheGet;
	  MapCache.prototype.has = mapCacheHas;
	  MapCache.prototype.set = mapCacheSet;
	  /**
	   *
	   * Creates an array cache object to store unique values.
	   *
	   * @private
	   * @constructor
	   * @param {Array} [values] The values to cache.
	   */

	  function SetCache(values) {
	    var index = -1,
	        length = values == null ? 0 : values.length;
	    this.__data__ = new MapCache();

	    while (++index < length) {
	      this.add(values[index]);
	    }
	  }
	  /**
	   * Adds `value` to the array cache.
	   *
	   * @private
	   * @name add
	   * @memberOf SetCache
	   * @alias push
	   * @param {*} value The value to cache.
	   * @returns {Object} Returns the cache instance.
	   */


	  function setCacheAdd(value) {
	    this.__data__.set(value, HASH_UNDEFINED);

	    return this;
	  }
	  /**
	   * Checks if `value` is in the array cache.
	   *
	   * @private
	   * @name has
	   * @memberOf SetCache
	   * @param {*} value The value to search for.
	   * @returns {number} Returns `true` if `value` is found, else `false`.
	   */


	  function setCacheHas(value) {
	    return this.__data__.has(value);
	  } // Add methods to `SetCache`.


	  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	  SetCache.prototype.has = setCacheHas;
	  /**
	   * Creates a stack cache object to store key-value pairs.
	   *
	   * @private
	   * @constructor
	   * @param {Array} [entries] The key-value pairs to cache.
	   */

	  function Stack(entries) {
	    var data = this.__data__ = new ListCache(entries);
	    this.size = data.size;
	  }
	  /**
	   * Removes all key-value entries from the stack.
	   *
	   * @private
	   * @name clear
	   * @memberOf Stack
	   */


	  function stackClear() {
	    this.__data__ = new ListCache();
	    this.size = 0;
	  }
	  /**
	   * Removes `key` and its value from the stack.
	   *
	   * @private
	   * @name delete
	   * @memberOf Stack
	   * @param {string} key The key of the value to remove.
	   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	   */


	  function stackDelete(key) {
	    var data = this.__data__,
	        result = data['delete'](key);
	    this.size = data.size;
	    return result;
	  }
	  /**
	   * Gets the stack value for `key`.
	   *
	   * @private
	   * @name get
	   * @memberOf Stack
	   * @param {string} key The key of the value to get.
	   * @returns {*} Returns the entry value.
	   */


	  function stackGet(key) {
	    return this.__data__.get(key);
	  }
	  /**
	   * Checks if a stack value for `key` exists.
	   *
	   * @private
	   * @name has
	   * @memberOf Stack
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */


	  function stackHas(key) {
	    return this.__data__.has(key);
	  }
	  /**
	   * Sets the stack `key` to `value`.
	   *
	   * @private
	   * @name set
	   * @memberOf Stack
	   * @param {string} key The key of the value to set.
	   * @param {*} value The value to set.
	   * @returns {Object} Returns the stack cache instance.
	   */


	  function stackSet(key, value) {
	    var data = this.__data__;

	    if (data instanceof ListCache) {
	      var pairs = data.__data__;

	      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
	        pairs.push([key, value]);
	        this.size = ++data.size;
	        return this;
	      }

	      data = this.__data__ = new MapCache(pairs);
	    }

	    data.set(key, value);
	    this.size = data.size;
	    return this;
	  } // Add methods to `Stack`.


	  Stack.prototype.clear = stackClear;
	  Stack.prototype['delete'] = stackDelete;
	  Stack.prototype.get = stackGet;
	  Stack.prototype.has = stackHas;
	  Stack.prototype.set = stackSet;
	  /**
	   * Creates an array of the enumerable property names of the array-like `value`.
	   *
	   * @private
	   * @param {*} value The value to query.
	   * @param {boolean} inherited Specify returning inherited property names.
	   * @returns {Array} Returns the array of property names.
	   */

	  function arrayLikeKeys(value, inherited) {
	    var isArr = isArray(value),
	        isArg = !isArr && isArguments(value),
	        isBuff = !isArr && !isArg && isBuffer(value),
	        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	        skipIndexes = isArr || isArg || isBuff || isType,
	        result = skipIndexes ? baseTimes(value.length, String) : [],
	        length = result.length;

	    for (var key in value) {
	      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
	      key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
	      isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
	      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
	      isIndex(key, length)))) {
	        result.push(key);
	      }
	    }

	    return result;
	  }
	  /**
	   * Gets the index at which the `key` is found in `array` of key-value pairs.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} key The key to search for.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */


	  function assocIndexOf(array, key) {
	    var length = array.length;

	    while (length--) {
	      if (eq(array[length][0], key)) {
	        return length;
	      }
	    }

	    return -1;
	  }
	  /**
	   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	   * symbols of `object`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Function} keysFunc The function to get the keys of `object`.
	   * @param {Function} symbolsFunc The function to get the symbols of `object`.
	   * @returns {Array} Returns the array of property names and symbols.
	   */


	  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	    var result = keysFunc(object);
	    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	  }
	  /**
	   * The base implementation of `getTag` without fallbacks for buggy environments.
	   *
	   * @private
	   * @param {*} value The value to query.
	   * @returns {string} Returns the `toStringTag`.
	   */


	  function baseGetTag(value) {
	    if (value == null) {
	      return value === undefined ? undefinedTag : nullTag;
	    }

	    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
	  }
	  /**
	   * The base implementation of `_.isArguments`.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	   */


	  function baseIsArguments(value) {
	    return isObjectLike(value) && baseGetTag(value) == argsTag;
	  }
	  /**
	   * The base implementation of `_.isEqual` which supports partial comparisons
	   * and tracks traversed objects.
	   *
	   * @private
	   * @param {*} value The value to compare.
	   * @param {*} other The other value to compare.
	   * @param {boolean} bitmask The bitmask flags.
	   *  1 - Unordered comparison
	   *  2 - Partial comparison
	   * @param {Function} [customizer] The function to customize comparisons.
	   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	   */


	  function baseIsEqual(value, other, bitmask, customizer, stack) {
	    if (value === other) {
	      return true;
	    }

	    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
	      return value !== value && other !== other;
	    }

	    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	  }
	  /**
	   * A specialized version of `baseIsEqual` for arrays and objects which performs
	   * deep comparisons and tracks traversed objects enabling objects with circular
	   * references to be compared.
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	   * @param {Function} customizer The function to customize comparisons.
	   * @param {Function} equalFunc The function to determine equivalents of values.
	   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	   */


	  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	    var objIsArr = isArray(object),
	        othIsArr = isArray(other),
	        objTag = objIsArr ? arrayTag : getTag(object),
	        othTag = othIsArr ? arrayTag : getTag(other);
	    objTag = objTag == argsTag ? objectTag : objTag;
	    othTag = othTag == argsTag ? objectTag : othTag;
	    var objIsObj = objTag == objectTag,
	        othIsObj = othTag == objectTag,
	        isSameTag = objTag == othTag;

	    if (isSameTag && isBuffer(object)) {
	      if (!isBuffer(other)) {
	        return false;
	      }

	      objIsArr = true;
	      objIsObj = false;
	    }

	    if (isSameTag && !objIsObj) {
	      stack || (stack = new Stack());
	      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	    }

	    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	      if (objIsWrapped || othIsWrapped) {
	        var objUnwrapped = objIsWrapped ? object.value() : object,
	            othUnwrapped = othIsWrapped ? other.value() : other;
	        stack || (stack = new Stack());
	        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	      }
	    }

	    if (!isSameTag) {
	      return false;
	    }

	    stack || (stack = new Stack());
	    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	  }
	  /**
	   * The base implementation of `_.isNative` without bad shim checks.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a native function,
	   *  else `false`.
	   */


	  function baseIsNative(value) {
	    if (!isObject(value) || isMasked(value)) {
	      return false;
	    }

	    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	    return pattern.test(toSource(value));
	  }
	  /**
	   * The base implementation of `_.isTypedArray` without Node.js optimizations.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	   */


	  function baseIsTypedArray(value) {
	    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	  }
	  /**
	   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Array} Returns the array of property names.
	   */


	  function baseKeys(object) {
	    if (!isPrototype(object)) {
	      return nativeKeys(object);
	    }

	    var result = [];

	    for (var key in Object(object)) {
	      if (hasOwnProperty.call(object, key) && key != 'constructor') {
	        result.push(key);
	      }
	    }

	    return result;
	  }
	  /**
	   * A specialized version of `baseIsEqualDeep` for arrays with support for
	   * partial deep comparisons.
	   *
	   * @private
	   * @param {Array} array The array to compare.
	   * @param {Array} other The other array to compare.
	   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	   * @param {Function} customizer The function to customize comparisons.
	   * @param {Function} equalFunc The function to determine equivalents of values.
	   * @param {Object} stack Tracks traversed `array` and `other` objects.
	   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	   */


	  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	        arrLength = array.length,
	        othLength = other.length;

	    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	      return false;
	    } // Assume cyclic values are equal.


	    var stacked = stack.get(array);

	    if (stacked && stack.get(other)) {
	      return stacked == other;
	    }

	    var index = -1,
	        result = true,
	        seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
	    stack.set(array, other);
	    stack.set(other, array); // Ignore non-index properties.

	    while (++index < arrLength) {
	      var arrValue = array[index],
	          othValue = other[index];

	      if (customizer) {
	        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
	      }

	      if (compared !== undefined) {
	        if (compared) {
	          continue;
	        }

	        result = false;
	        break;
	      } // Recursively compare arrays (susceptible to call stack limits).


	      if (seen) {
	        if (!arraySome(other, function (othValue, othIndex) {
	          if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	            return seen.push(othIndex);
	          }
	        })) {
	          result = false;
	          break;
	        }
	      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	        result = false;
	        break;
	      }
	    }

	    stack['delete'](array);
	    stack['delete'](other);
	    return result;
	  }
	  /**
	   * A specialized version of `baseIsEqualDeep` for comparing objects of
	   * the same `toStringTag`.
	   *
	   * **Note:** This function only supports comparing values with tags of
	   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @param {string} tag The `toStringTag` of the objects to compare.
	   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	   * @param {Function} customizer The function to customize comparisons.
	   * @param {Function} equalFunc The function to determine equivalents of values.
	   * @param {Object} stack Tracks traversed `object` and `other` objects.
	   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	   */


	  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	    switch (tag) {
	      case dataViewTag:
	        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
	          return false;
	        }

	        object = object.buffer;
	        other = other.buffer;

	      case arrayBufferTag:
	        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	          return false;
	        }

	        return true;

	      case boolTag:
	      case dateTag:
	      case numberTag:
	        // Coerce booleans to `1` or `0` and dates to milliseconds.
	        // Invalid dates are coerced to `NaN`.
	        return eq(+object, +other);

	      case errorTag:
	        return object.name == other.name && object.message == other.message;

	      case regexpTag:
	      case stringTag:
	        // Coerce regexes to strings and treat strings, primitives and objects,
	        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	        // for more details.
	        return object == other + '';

	      case mapTag:
	        var convert = mapToArray;

	      case setTag:
	        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	        convert || (convert = setToArray);

	        if (object.size != other.size && !isPartial) {
	          return false;
	        } // Assume cyclic values are equal.


	        var stacked = stack.get(object);

	        if (stacked) {
	          return stacked == other;
	        }

	        bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

	        stack.set(object, other);
	        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	        stack['delete'](object);
	        return result;

	      case symbolTag:
	        if (symbolValueOf) {
	          return symbolValueOf.call(object) == symbolValueOf.call(other);
	        }

	    }

	    return false;
	  }
	  /**
	   * A specialized version of `baseIsEqualDeep` for objects with support for
	   * partial deep comparisons.
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	   * @param {Function} customizer The function to customize comparisons.
	   * @param {Function} equalFunc The function to determine equivalents of values.
	   * @param {Object} stack Tracks traversed `object` and `other` objects.
	   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	   */


	  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	        objProps = getAllKeys(object),
	        objLength = objProps.length,
	        othProps = getAllKeys(other),
	        othLength = othProps.length;

	    if (objLength != othLength && !isPartial) {
	      return false;
	    }

	    var index = objLength;

	    while (index--) {
	      var key = objProps[index];

	      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	        return false;
	      }
	    } // Assume cyclic values are equal.


	    var stacked = stack.get(object);

	    if (stacked && stack.get(other)) {
	      return stacked == other;
	    }

	    var result = true;
	    stack.set(object, other);
	    stack.set(other, object);
	    var skipCtor = isPartial;

	    while (++index < objLength) {
	      key = objProps[index];
	      var objValue = object[key],
	          othValue = other[key];

	      if (customizer) {
	        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
	      } // Recursively compare objects (susceptible to call stack limits).


	      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
	        result = false;
	        break;
	      }

	      skipCtor || (skipCtor = key == 'constructor');
	    }

	    if (result && !skipCtor) {
	      var objCtor = object.constructor,
	          othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

	      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	        result = false;
	      }
	    }

	    stack['delete'](object);
	    stack['delete'](other);
	    return result;
	  }
	  /**
	   * Creates an array of own enumerable property names and symbols of `object`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Array} Returns the array of property names and symbols.
	   */


	  function getAllKeys(object) {
	    return baseGetAllKeys(object, keys, getSymbols);
	  }
	  /**
	   * Gets the data for `map`.
	   *
	   * @private
	   * @param {Object} map The map to query.
	   * @param {string} key The reference key.
	   * @returns {*} Returns the map data.
	   */


	  function getMapData(map, key) {
	    var data = map.__data__;
	    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
	  }
	  /**
	   * Gets the native function at `key` of `object`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {string} key The key of the method to get.
	   * @returns {*} Returns the function if it's native, else `undefined`.
	   */


	  function getNative(object, key) {
	    var value = getValue(object, key);
	    return baseIsNative(value) ? value : undefined;
	  }
	  /**
	   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	   *
	   * @private
	   * @param {*} value The value to query.
	   * @returns {string} Returns the raw `toStringTag`.
	   */


	  function getRawTag(value) {
	    var isOwn = hasOwnProperty.call(value, symToStringTag),
	        tag = value[symToStringTag];

	    try {
	      value[symToStringTag] = undefined;
	      var unmasked = true;
	    } catch (e) {}

	    var result = nativeObjectToString.call(value);

	    if (unmasked) {
	      if (isOwn) {
	        value[symToStringTag] = tag;
	      } else {
	        delete value[symToStringTag];
	      }
	    }

	    return result;
	  }
	  /**
	   * Creates an array of the own enumerable symbols of `object`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Array} Returns the array of symbols.
	   */


	  var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
	    if (object == null) {
	      return [];
	    }

	    object = Object(object);
	    return arrayFilter(nativeGetSymbols(object), function (symbol) {
	      return propertyIsEnumerable.call(object, symbol);
	    });
	  };
	  /**
	   * Gets the `toStringTag` of `value`.
	   *
	   * @private
	   * @param {*} value The value to query.
	   * @returns {string} Returns the `toStringTag`.
	   */

	  var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

	  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
	    getTag = function getTag(value) {
	      var result = baseGetTag(value),
	          Ctor = result == objectTag ? value.constructor : undefined,
	          ctorString = Ctor ? toSource(Ctor) : '';

	      if (ctorString) {
	        switch (ctorString) {
	          case dataViewCtorString:
	            return dataViewTag;

	          case mapCtorString:
	            return mapTag;

	          case promiseCtorString:
	            return promiseTag;

	          case setCtorString:
	            return setTag;

	          case weakMapCtorString:
	            return weakMapTag;
	        }
	      }

	      return result;
	    };
	  }
	  /**
	   * Checks if `value` is a valid array-like index.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	   */


	  function isIndex(value, length) {
	    length = length == null ? MAX_SAFE_INTEGER : length;
	    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
	  }
	  /**
	   * Checks if `value` is suitable for use as unique object key.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	   */


	  function isKeyable(value) {
	    var type = typeof value;
	    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
	  }
	  /**
	   * Checks if `func` has its source masked.
	   *
	   * @private
	   * @param {Function} func The function to check.
	   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	   */


	  function isMasked(func) {
	    return !!maskSrcKey && maskSrcKey in func;
	  }
	  /**
	   * Checks if `value` is likely a prototype object.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	   */


	  function isPrototype(value) {
	    var Ctor = value && value.constructor,
	        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
	    return value === proto;
	  }
	  /**
	   * Converts `value` to a string using `Object.prototype.toString`.
	   *
	   * @private
	   * @param {*} value The value to convert.
	   * @returns {string} Returns the converted string.
	   */


	  function objectToString(value) {
	    return nativeObjectToString.call(value);
	  }
	  /**
	   * Converts `func` to its source code.
	   *
	   * @private
	   * @param {Function} func The function to convert.
	   * @returns {string} Returns the source code.
	   */


	  function toSource(func) {
	    if (func != null) {
	      try {
	        return funcToString.call(func);
	      } catch (e) {}

	      try {
	        return func + '';
	      } catch (e) {}
	    }

	    return '';
	  }
	  /**
	   * Performs a
	   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	   * comparison between two values to determine if they are equivalent.
	   *
	   * @static
	   * @memberOf _
	   * @since 4.0.0
	   * @category Lang
	   * @param {*} value The value to compare.
	   * @param {*} other The other value to compare.
	   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	   * @example
	   *
	   * var object = { 'a': 1 };
	   * var other = { 'a': 1 };
	   *
	   * _.eq(object, object);
	   * // => true
	   *
	   * _.eq(object, other);
	   * // => false
	   *
	   * _.eq('a', 'a');
	   * // => true
	   *
	   * _.eq('a', Object('a'));
	   * // => false
	   *
	   * _.eq(NaN, NaN);
	   * // => true
	   */


	  function eq(value, other) {
	    return value === other || value !== value && other !== other;
	  }
	  /**
	   * Checks if `value` is likely an `arguments` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 0.1.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	   *  else `false`.
	   * @example
	   *
	   * _.isArguments(function() { return arguments; }());
	   * // => true
	   *
	   * _.isArguments([1, 2, 3]);
	   * // => false
	   */


	  var isArguments = baseIsArguments(function () {
	    return arguments;
	  }()) ? baseIsArguments : function (value) {
	    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
	  };
	  /**
	   * Checks if `value` is classified as an `Array` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 0.1.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	   * @example
	   *
	   * _.isArray([1, 2, 3]);
	   * // => true
	   *
	   * _.isArray(document.body.children);
	   * // => false
	   *
	   * _.isArray('abc');
	   * // => false
	   *
	   * _.isArray(_.noop);
	   * // => false
	   */

	  var isArray = Array.isArray;
	  /**
	   * Checks if `value` is array-like. A value is considered array-like if it's
	   * not a function and has a `value.length` that's an integer greater than or
	   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	   *
	   * @static
	   * @memberOf _
	   * @since 4.0.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	   * @example
	   *
	   * _.isArrayLike([1, 2, 3]);
	   * // => true
	   *
	   * _.isArrayLike(document.body.children);
	   * // => true
	   *
	   * _.isArrayLike('abc');
	   * // => true
	   *
	   * _.isArrayLike(_.noop);
	   * // => false
	   */

	  function isArrayLike(value) {
	    return value != null && isLength(value.length) && !isFunction(value);
	  }
	  /**
	   * Checks if `value` is a buffer.
	   *
	   * @static
	   * @memberOf _
	   * @since 4.3.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	   * @example
	   *
	   * _.isBuffer(new Buffer(2));
	   * // => true
	   *
	   * _.isBuffer(new Uint8Array(2));
	   * // => false
	   */


	  var isBuffer = nativeIsBuffer || stubFalse;
	  /**
	   * Performs a deep comparison between two values to determine if they are
	   * equivalent.
	   *
	   * **Note:** This method supports comparing arrays, array buffers, booleans,
	   * date objects, error objects, maps, numbers, `Object` objects, regexes,
	   * sets, strings, symbols, and typed arrays. `Object` objects are compared
	   * by their own, not inherited, enumerable properties. Functions and DOM
	   * nodes are compared by strict equality, i.e. `===`.
	   *
	   * @static
	   * @memberOf _
	   * @since 0.1.0
	   * @category Lang
	   * @param {*} value The value to compare.
	   * @param {*} other The other value to compare.
	   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	   * @example
	   *
	   * var object = { 'a': 1 };
	   * var other = { 'a': 1 };
	   *
	   * _.isEqual(object, other);
	   * // => true
	   *
	   * object === other;
	   * // => false
	   */

	  function isEqual(value, other) {
	    return baseIsEqual(value, other);
	  }
	  /**
	   * Checks if `value` is classified as a `Function` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 0.1.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	   * @example
	   *
	   * _.isFunction(_);
	   * // => true
	   *
	   * _.isFunction(/abc/);
	   * // => false
	   */


	  function isFunction(value) {
	    if (!isObject(value)) {
	      return false;
	    } // The use of `Object#toString` avoids issues with the `typeof` operator
	    // in Safari 9 which returns 'object' for typed arrays and other constructors.


	    var tag = baseGetTag(value);
	    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	  }
	  /**
	   * Checks if `value` is a valid array-like length.
	   *
	   * **Note:** This method is loosely based on
	   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	   *
	   * @static
	   * @memberOf _
	   * @since 4.0.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	   * @example
	   *
	   * _.isLength(3);
	   * // => true
	   *
	   * _.isLength(Number.MIN_VALUE);
	   * // => false
	   *
	   * _.isLength(Infinity);
	   * // => false
	   *
	   * _.isLength('3');
	   * // => false
	   */


	  function isLength(value) {
	    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	  }
	  /**
	   * Checks if `value` is the
	   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	   *
	   * @static
	   * @memberOf _
	   * @since 0.1.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	   * @example
	   *
	   * _.isObject({});
	   * // => true
	   *
	   * _.isObject([1, 2, 3]);
	   * // => true
	   *
	   * _.isObject(_.noop);
	   * // => true
	   *
	   * _.isObject(null);
	   * // => false
	   */


	  function isObject(value) {
	    var type = typeof value;
	    return value != null && (type == 'object' || type == 'function');
	  }
	  /**
	   * Checks if `value` is object-like. A value is object-like if it's not `null`
	   * and has a `typeof` result of "object".
	   *
	   * @static
	   * @memberOf _
	   * @since 4.0.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	   * @example
	   *
	   * _.isObjectLike({});
	   * // => true
	   *
	   * _.isObjectLike([1, 2, 3]);
	   * // => true
	   *
	   * _.isObjectLike(_.noop);
	   * // => false
	   *
	   * _.isObjectLike(null);
	   * // => false
	   */


	  function isObjectLike(value) {
	    return value != null && typeof value == 'object';
	  }
	  /**
	   * Checks if `value` is classified as a typed array.
	   *
	   * @static
	   * @memberOf _
	   * @since 3.0.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	   * @example
	   *
	   * _.isTypedArray(new Uint8Array);
	   * // => true
	   *
	   * _.isTypedArray([]);
	   * // => false
	   */


	  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	  /**
	   * Creates an array of the own enumerable property names of `object`.
	   *
	   * **Note:** Non-object values are coerced to objects. See the
	   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	   * for more details.
	   *
	   * @static
	   * @since 0.1.0
	   * @memberOf _
	   * @category Object
	   * @param {Object} object The object to query.
	   * @returns {Array} Returns the array of property names.
	   * @example
	   *
	   * function Foo() {
	   *   this.a = 1;
	   *   this.b = 2;
	   * }
	   *
	   * Foo.prototype.c = 3;
	   *
	   * _.keys(new Foo);
	   * // => ['a', 'b'] (iteration order is not guaranteed)
	   *
	   * _.keys('hi');
	   * // => ['0', '1']
	   */

	  function keys(object) {
	    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	  }
	  /**
	   * This method returns a new empty array.
	   *
	   * @static
	   * @memberOf _
	   * @since 4.13.0
	   * @category Util
	   * @returns {Array} Returns the new empty array.
	   * @example
	   *
	   * var arrays = _.times(2, _.stubArray);
	   *
	   * console.log(arrays);
	   * // => [[], []]
	   *
	   * console.log(arrays[0] === arrays[1]);
	   * // => false
	   */


	  function stubArray() {
	    return [];
	  }
	  /**
	   * This method returns `false`.
	   *
	   * @static
	   * @memberOf _
	   * @since 4.13.0
	   * @category Util
	   * @returns {boolean} Returns `false`.
	   * @example
	   *
	   * _.times(2, _.stubFalse);
	   * // => [false, false]
	   */


	  function stubFalse() {
	    return false;
	  }

	  module.exports = isEqual;
	});

	var handleMediaGroups = function handleMediaGroups(obj) {
	  var keys = Object.keys(obj);
	  var result = '';
	  keys.forEach(function (key) {
	    // samples
	    // #EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="audio0",NAME="fra",DEFAULT=YES,AUTOSELECT=YES,LANGUAGE="fra",URI="audio_64_fra_rendition.m3u8"
	    // #EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID="subtitles0",NAME="eng_subtitle",DEFAULT=NO,AUTOSELECT=YES,LANGUAGE="eng",URI="subtitle_eng_rendition.m3u8"
	    // #EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID="low",NAME="Dugout",DEFAULT=NO,URI="low/dugout/audio-video.m3u8"
	    // iterating group-id
	    var keyGroupId = Object.keys(obj[key]);
	    keyGroupId.forEach(function (groupId) {
	      var groupData = obj[key][groupId]; // iterating languages

	      var keyName = Object.keys(groupData);
	      keyName.forEach(function (Name) {
	        var mediaGroupItem = "#EXT-X-MEDIA:TYPE=" + key;
	        mediaGroupItem += ",GROUP-ID=\"" + groupId + "\"";
	        mediaGroupItem += ",NAME=\"" + Name + "\"";
	        var entryKeys = Object.keys(groupData[Name]);
	        entryKeys.forEach(function (entryKey) {
	          var value = groupData[Name][entryKey];
	          var QuotedAttributes = ['URI', 'LANGUAGE', 'ASSOC-LANGUAGE', 'INSTREAM-ID', 'CHARACTERISTICS', 'CHANNELS'];

	          if (entryKey === 'instreamId') {
	            // special case: key not compatible with rfc
	            entryKey = 'INSTREAM-ID';
	          }

	          var isQuoted = QuotedAttributes.includes(entryKey.toUpperCase());
	          mediaGroupItem += "," + entryKey.toUpperCase() + "=" + (isQuoted ? '"' : '') + value + (isQuoted ? '"' : '');
	        });
	        result += mediaGroupItem + '\n';
	      });
	    });
	  });
	  return result + '\n';
	};

	function handlePlaylists(arrPlaylists) {
	  // samples
	  // #EXT-X-STREAM-INF:AVERAGE-BANDWIDTH=20985770,BANDWIDTH=28058971,VIDEO-RANGE=SDR,CODECS="hvc1.2.4.L150.B0",RESOLUTION=3840x2160,FRAME-RATE=23.976,CLOSED-CAPTIONS=NONE,HDCP-LEVEL=TYPE-1
	  // sdr_2160/prog_index.m3u8
	  var result = '';
	  arrPlaylists.forEach(function (playlist) {
	    var playlistItem = '#EXT-X-STREAM-INF:';
	    var attrKeys = Object.keys(playlist.attributes);
	    attrKeys.forEach(function (attribute) {
	      // FIXME: an enumarated-string NONE should not be quoted in CLOSED-CAPTION attr
	      var QuotedAttributes = ['CODECS', 'AUDIO', 'VIDEO', 'SUBTITLES', 'CLOSED-CAPTIONS'];
	      var isQuoted = QuotedAttributes.includes(attribute.toUpperCase());
	      var value = playlist.attributes[attribute];

	      if (attribute === 'RESOLUTION') {
	        // changing object data to hls desired format
	        value = value.width + "x" + value.height;
	      }

	      if (attribute === 'FRAME-RATE') {
	        // rounding FRAME-RATE to 3 decimal places
	        value = parseFloat(value).toFixed(3);
	      }

	      playlistItem += "," + attribute.toUpperCase() + "=" + (isQuoted ? '"' : '') + value + (isQuoted ? '"' : '');
	    }); // adding uri

	    playlistItem += "\n" + playlist.uri + "\n";
	    result += playlistItem + '\n';
	  });
	  return result;
	}

	function toHexString(uint32) {
	  return uint32.reduce(function (output, elem) {
	    return output + ('00000000' + elem.toString(16)).slice(-8);
	  }, '');
	}

	function handleSegments(segments) {
	  var result = '';
	  var lastKey = {};
	  var lastMap = {};
	  segments.forEach(function (segment) {
	    var segmentString = '\n'; // if segment.key does not exists, it does not mean that no tag should be placed there
	    // it just mean there is no key associated with that segment
	    // As the HLS RFC points out, if we have set an encryption method at some point (maybe segment 30)
	    // and from now on (segment 50) we don't need that (segments are not encrypted anymore),
	    // we cannot just leave it like that. we should add "#EXT-X-KEY:METHOD=NONE" to tell no encrption from now on
	    // more info: https://tools.ietf.org/html/rfc8216#section-4.3.2.4
	    // NOTE: if we have #EXT-X-KEY:METHOD=NONE , segment.key won't be present at all
	    // NOTE: encryption for Widevine is not supported in stringifying
	    // lodash.isequal is a little bit overkill for this usecase, but I didn't want to
	    // add object equality function. They are confusing and ugly

	    if (segment.key && !lodash_isequal(segment.key, lastKey)) {
	      // segment key exists and is not equel to last key
	      var IV = segment.key.iv ? ",IV=0x" + toHexString(segment.key.iv) : '';
	      segmentString += "#EXT-X-KEY:METHOD=" + segment.key.method + ",URI=\"" + segment.key.uri + "\"" + IV + "\n";
	      lastKey = segment.key;
	    } else if (!segment.key && !isEmpty(lastKey)) {
	      // segment.key does not exists and if we have a lastkey, we sould add #EXT-X-KEY:METHOD=NONE
	      segmentString += '#EXT-X-KEY:METHOD=NONE\n';
	    }

	    if (segment.map && !lodash_isequal(segment.map, lastMap)) {
	      // segment map exists and is not equel to last map
	      if (typeof segment.map.byterange.offset === 'undefined') {
	        segment.map.byterange.offset = 0;
	      }

	      var BYTERANGE = segment.map.byterange ? ",BYTERANGE=\"" + segment.map.byterange.length + "@" + segment.map.byterange.offset + "\"" : '';
	      segmentString += "#EXT-X-MAP:URI=\"" + segment.map.uri + "\"" + BYTERANGE + "\n";
	      lastMap = segment.map;
	    }

	    if (segment.discontinuity) {
	      segmentString += '#EXT-X-DISCONTINUITY\n';
	    }
	    /*
	      "A Media Playlist MUST indicate an EXT-X-VERSION of 3 or higher if it contains:
	        Floating-point EXTINF duration values." - https://tools.ietf.org/html/rfc8216#section-7
	       So, we cannot alter or parse decimal target duration to floating point
	      because it might introduce version incompatibility
	    */
	    // FIXME: What about name after duration?


	    segmentString += "#EXTINF:" + segment.duration + ",\n"; // TODO: which one should appear first? byterange or program date time?

	    if (segment.dateTimeString) {
	      segmentString += "#EXT-X-PROGRAM-DATE-TIME:" + segment.dateTimeString + "\n";
	    }

	    if (segment.byterange) {
	      // even though offset is optional in hls specs, but it is always present in manifest object
	      var length = segment.byterange.length;
	      var offset = segment.byterange.offset;
	      segmentString += "#EXT-X-BYTERANGE:" + length + "@" + offset + "\n";
	    }

	    segmentString += segment.uri;
	    result += segmentString + '\n';
	  });
	  return result;
	}

	function stringifyTag(key, value) {
	  // key indicated the tag
	  // TODO: should we include #EXT-X-PROGRAM-DATE-TIME as playlist tag?
	  if (key === 'allowCache') {
	    // FIXME: this tag is deprecated
	    return "#EXT-X-ALLOW-CACHE:" + (value ? 'YES' : 'NO') + "\n";
	  } else if (key === 'discontinuityStarts') {
	    // not implemented
	    return '';
	  } else if (key === 'version') {
	    return "#EXT-X-VERSION:" + value + "\n";
	  } else if (key === 'mediaGroups') {
	    // handling media groups seperately
	    return handleMediaGroups(value);
	  } else if (key === 'playlists') {
	    // handling media groups seperately
	    return handlePlaylists(value);
	  } else if (key === 'targetDuration') {
	    return "#EXT-X-TARGETDURATION:" + value + "\n";
	  } else if (key === 'mediaSequence') {
	    return "#EXT-X-MEDIA-SEQUENCE:" + value + "\n";
	  } else if (key === 'playlistType') {
	    return "#EXT-X-PLAYLIST-TYPE:" + value + "\n";
	  } else if (key === 'segments') {
	    // handle segments seperately
	    return handleSegments(value);
	  } else if (key === 'discontinuitySequence') {
	    return "#EXT-X-DISCONTINUITY-SEQUENCE:" + value + "\n";
	  } else if (key === 'start') {
	    return "#EXT-X-START:TIME-OFFSET=" + value.timeOffset + ",PRECISE=" + value.precise + "\n";
	  } else if (key === 'endList') {
	    if (value) {
	      return '#EXT-X-ENDLIST\n';
	    } // if value is false tag should not be present


	    return '';
	  } else if (key === 'independentSegments') {
	    return '#EXT-X-INDEPENDENT-SEGMENTS\n';
	  } // unknown tag


	  return '';
	}

	function isEmpty(element) {
	  if (typeof element === 'object' && (element.constructor === Object || element.constructor === Array) && Object.keys(element).length === 0) {
	    // typeof [] === 'object'
	    // Object.keys(["One", "Two", "Three"]) === ["0", "1", "2"]
	    return true;
	  }

	  return false;
	} // EXTM3U is not present, becuase it is not present in manifest object
	// ["EXT-X-VERSION", "#EXT-X-MEDIA", "#EXT-X-STREAM-INF", "#EXT-X-TARGETDURATION", "#EXT-X-MEDIA-SEQUENCE", "#EXT-X-PLAYLIST-TYPE", "#EXT-X-DISCONTINUITY-SEQUENCE", "#EXT-X-INDEPENDENT-SEGMENTS", "#EXT-X-START", "#EXTINF", "#EXT-X-ENDLIST"];
	// #EXT-X-PROGRAM-DATE-TIME , #EXT-X-KEY , #EXT-X-MAP , #EXT-X-BYTERANGE and #EXT-X-DISCONTINUITY will be created in segments
	// below is equivalent in manifest object


	var tagsInOrder = ['version', 'mediaGroups', 'playlists', 'targetDuration', 'mediaSequence', 'playlistType', 'discontinuitySequence', 'independentSegments', 'start', 'segments', 'endList'];
	function Writer(manifest) {
	  var stringified = ''; // adding #EXTM3U in the first place
	  // adding new line manullay in every line

	  stringified += '#EXTM3U\n';
	  var manifestKeys = Object.keys(manifest);
	  tagsInOrder.forEach(function (tag) {
	    if (manifestKeys.includes(tag) && !isEmpty(manifestKeys[tag])) {
	      // tag === keys in manifestKeys
	      stringified += stringifyTag(tag, manifest[tag]);
	    }
	  }); // remove , after :

	  stringified = stringified.replace(/:,/g, ':'); // replacing true and false with YES and NO
	  // because true and false were used in manifest obj

	  stringified = stringified.replace(/true/g, 'YES');
	  stringified = stringified.replace(/false/g, 'NO');
	  return stringified;
	}

	var camelCase = function camelCase(str) {
	  return str.toLowerCase().replace(/-(\w)/g, function (a) {
	    return a[1].toUpperCase();
	  });
	};

	var camelCaseKeys = function camelCaseKeys(attributes) {
	  var result = {};
	  Object.keys(attributes).forEach(function (key) {
	    result[camelCase(key)] = attributes[key];
	  });
	  return result;
	}; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration
	// we need this helper because defaults are based upon targetDuration and
	// partTargetDuration being set, but they may not be if SERVER-CONTROL appears before
	// target durations are set.


	var setHoldBack = function setHoldBack(manifest) {
	  var serverControl = manifest.serverControl,
	      targetDuration = manifest.targetDuration,
	      partTargetDuration = manifest.partTargetDuration;

	  if (!serverControl) {
	    return;
	  }

	  var tag = '#EXT-X-SERVER-CONTROL';
	  var hb = 'holdBack';
	  var phb = 'partHoldBack';
	  var minTargetDuration = targetDuration && targetDuration * 3;
	  var minPartDuration = partTargetDuration && partTargetDuration * 2;

	  if (targetDuration && !serverControl.hasOwnProperty(hb)) {
	    serverControl[hb] = minTargetDuration;
	    this.trigger('info', {
	      message: tag + " defaulting HOLD-BACK to targetDuration * 3 (" + minTargetDuration + ")."
	    });
	  }

	  if (minTargetDuration && serverControl[hb] < minTargetDuration) {
	    this.trigger('warn', {
	      message: tag + " clamping HOLD-BACK (" + serverControl[hb] + ") to targetDuration * 3 (" + minTargetDuration + ")"
	    });
	    serverControl[hb] = minTargetDuration;
	  } // default no part hold back to part target duration * 3


	  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {
	    serverControl[phb] = partTargetDuration * 3;
	    this.trigger('info', {
	      message: tag + " defaulting PART-HOLD-BACK to partTargetDuration * 3 (" + serverControl[phb] + ")."
	    });
	  } // if part hold back is too small default it to part target duration * 2


	  if (partTargetDuration && serverControl[phb] < minPartDuration) {
	    this.trigger('warn', {
	      message: tag + " clamping PART-HOLD-BACK (" + serverControl[phb] + ") to partTargetDuration * 2 (" + minPartDuration + ")."
	    });
	    serverControl[phb] = minPartDuration;
	  }
	};
	/**
	 * A parser for M3U8 files. The current interpretation of the input is
	 * exposed as a property `manifest` on parser objects. It's just two lines to
	 * create and parse a manifest once you have the contents available as a string:
	 *
	 * ```js
	 * var parser = new m3u8.Parser();
	 * parser.push(xhr.responseText);
	 * ```
	 *
	 * New input can later be applied to update the manifest object by calling
	 * `push` again.
	 *
	 * The parser attempts to create a usable manifest object even if the
	 * underlying input is somewhat nonsensical. It emits `info` and `warning`
	 * events during the parse if it encounters input that seems invalid or
	 * requires some property of the manifest object to be defaulted.
	 *
	 * @class Parser
	 * @extends Stream
	 */


	var Parser = /*#__PURE__*/function (_Stream) {
	  inheritsLoose(Parser, _Stream);

	  function Parser() {
	    var _this;

	    _this = _Stream.call(this) || this;
	    _this.lineStream = new LineStream();
	    _this.parseStream = new ParseStream();

	    _this.lineStream.pipe(_this.parseStream);
	    /* eslint-disable consistent-this */


	    var self = assertThisInitialized(_this);
	    /* eslint-enable consistent-this */


	    var uris = [];
	    var currentUri = {}; // if specified, the active EXT-X-MAP definition

	    var currentMap; // if specified, the active decryption key

	    var _key;

	    var hasParts = false;

	    var noop = function noop() {};

	    var defaultMediaGroups = {
	      'AUDIO': {},
	      'VIDEO': {},
	      'CLOSED-CAPTIONS': {},
	      'SUBTITLES': {}
	    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is
	    // used in MPDs with Widevine encrypted streams.

	    var widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities

	    var currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data

	    _this.manifest = {
	      allowCache: true,
	      discontinuityStarts: [],
	      segments: []
	    }; // keep track of the last seen segment's byte range end, as segments are not required
	    // to provide the offset, in which case it defaults to the next byte after the
	    // previous segment

	    var lastByterangeEnd = 0; // keep track of the last seen part's byte range end.

	    var lastPartByterangeEnd = 0;

	    _this.on('end', function () {
	      // only add preloadSegment if we don't yet have a uri for it.
	      // and we actually have parts/preloadHints
	      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {
	        return;
	      }

	      if (!currentUri.map && currentMap) {
	        currentUri.map = currentMap;
	      }

	      if (!currentUri.key && _key) {
	        currentUri.key = _key;
	      }

	      if (!currentUri.timeline && typeof currentTimeline === 'number') {
	        currentUri.timeline = currentTimeline;
	      }

	      _this.manifest.preloadSegment = currentUri;
	    }); // update the manifest with the m3u8 entry from the parse stream


	    _this.parseStream.on('data', function (entry) {
	      var mediaGroup;
	      var rendition;
	      ({
	        tag: function tag() {
	          // switch based on the tag type
	          (({
	            version: function version() {
	              if (entry.version) {
	                this.manifest.version = entry.version;
	              }
	            },
	            'allow-cache': function allowCache() {
	              this.manifest.allowCache = entry.allowed;

	              if (!('allowed' in entry)) {
	                this.trigger('info', {
	                  message: 'defaulting allowCache to YES'
	                });
	                this.manifest.allowCache = true;
	              }
	            },
	            byterange: function byterange() {
	              var byterange = {};

	              if ('length' in entry) {
	                currentUri.byterange = byterange;
	                byterange.length = entry.length;

	                if (!('offset' in entry)) {
	                  /*
	                   * From the latest spec (as of this writing):
	                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2
	                   *
	                   * Same text since EXT-X-BYTERANGE's introduction in draft 7:
	                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)
	                   *
	                   * "If o [offset] is not present, the sub-range begins at the next byte
	                   * following the sub-range of the previous media segment."
	                   */
	                  entry.offset = lastByterangeEnd;
	                }
	              }

	              if ('offset' in entry) {
	                currentUri.byterange = byterange;
	                byterange.offset = entry.offset;
	              }

	              lastByterangeEnd = byterange.offset + byterange.length;
	            },
	            endlist: function endlist() {
	              this.manifest.endList = true;
	            },
	            'independent-segments': function independentSegments() {
	              this.manifest.independentSegments = true;
	            },
	            inf: function inf() {
	              if (!('mediaSequence' in this.manifest)) {
	                this.manifest.mediaSequence = 0;
	                this.trigger('info', {
	                  message: 'defaulting media sequence to zero'
	                });
	              }

	              if (!('discontinuitySequence' in this.manifest)) {
	                this.manifest.discontinuitySequence = 0;
	                this.trigger('info', {
	                  message: 'defaulting discontinuity sequence to zero'
	                });
	              }

	              if (entry.duration > 0) {
	                currentUri.duration = entry.duration;
	              }

	              if (entry.duration === 0) {
	                currentUri.duration = 0.01;
	                this.trigger('info', {
	                  message: 'updating zero segment duration to a small value'
	                });
	              }

	              this.manifest.segments = uris;
	            },
	            key: function key() {
	              if (!entry.attributes) {
	                this.trigger('warn', {
	                  message: 'ignoring key declaration without attribute list'
	                });
	                return;
	              } // clear the active encryption key


	              if (entry.attributes.METHOD === 'NONE') {
	                _key = null;
	                return;
	              }

	              if (!entry.attributes.URI) {
	                this.trigger('warn', {
	                  message: 'ignoring key declaration without URI'
	                });
	                return;
	              } // check if the content is encrypted for Widevine
	              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf


	              if (entry.attributes.KEYFORMAT === widevineUuid) {
	                var VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];

	                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {
	                  this.trigger('warn', {
	                    message: 'invalid key method provided for Widevine'
	                  });
	                  return;
	                }

	                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {
	                  this.trigger('warn', {
	                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'
	                  });
	                }

	                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {
	                  this.trigger('warn', {
	                    message: 'invalid key URI provided for Widevine'
	                  });
	                  return;
	                }

	                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {
	                  this.trigger('warn', {
	                    message: 'invalid key ID provided for Widevine'
	                  });
	                  return;
	                } // if Widevine key attributes are valid, store them as `contentProtection`
	                // on the manifest to emulate Widevine tag structure in a DASH mpd


	                this.manifest.contentProtection = {
	                  'com.widevine.alpha': {
	                    attributes: {
	                      schemeIdUri: entry.attributes.KEYFORMAT,
	                      // remove '0x' from the key id string
	                      keyId: entry.attributes.KEYID.substring(2)
	                    },
	                    // decode the base64-encoded PSSH box
	                    pssh: decodeB64ToUint8Array(entry.attributes.URI.split(',')[1])
	                  }
	                };
	                return;
	              }

	              if (!entry.attributes.METHOD) {
	                this.trigger('warn', {
	                  message: 'defaulting key method to AES-128'
	                });
	              } // setup an encryption key for upcoming segments


	              _key = {
	                method: entry.attributes.METHOD || 'AES-128',
	                uri: entry.attributes.URI
	              };

	              if (typeof entry.attributes.IV !== 'undefined') {
	                _key.iv = entry.attributes.IV;
	              }
	            },
	            'media-sequence': function mediaSequence() {
	              if (!isFinite(entry.number)) {
	                this.trigger('warn', {
	                  message: 'ignoring invalid media sequence: ' + entry.number
	                });
	                return;
	              }

	              this.manifest.mediaSequence = entry.number;
	            },
	            'discontinuity-sequence': function discontinuitySequence() {
	              if (!isFinite(entry.number)) {
	                this.trigger('warn', {
	                  message: 'ignoring invalid discontinuity sequence: ' + entry.number
	                });
	                return;
	              }

	              this.manifest.discontinuitySequence = entry.number;
	              currentTimeline = entry.number;
	            },
	            'playlist-type': function playlistType() {
	              if (!/VOD|EVENT/.test(entry.playlistType)) {
	                this.trigger('warn', {
	                  message: 'ignoring unknown playlist type: ' + entry.playlist
	                });
	                return;
	              }

	              this.manifest.playlistType = entry.playlistType;
	            },
	            map: function map() {
	              currentMap = {};

	              if (entry.uri) {
	                currentMap.uri = entry.uri;
	              }

	              if (entry.byterange) {
	                currentMap.byterange = entry.byterange;
	              }
	            },
	            'stream-inf': function streamInf() {
	              this.manifest.playlists = uris;
	              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;

	              if (!entry.attributes) {
	                this.trigger('warn', {
	                  message: 'ignoring empty stream-inf attributes'
	                });
	                return;
	              }

	              if (!currentUri.attributes) {
	                currentUri.attributes = {};
	              }

	              _extends_1(currentUri.attributes, entry.attributes);
	            },
	            media: function media() {
	              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;

	              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {
	                this.trigger('warn', {
	                  message: 'ignoring incomplete or missing media group'
	                });
	                return;
	              } // find the media group, creating defaults as necessary


	              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];
	              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};
	              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata

	              rendition = {
	                default: /yes/i.test(entry.attributes.DEFAULT)
	              };

	              if (rendition.default) {
	                rendition.autoselect = true;
	              } else {
	                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);
	              }

	              if (entry.attributes.LANGUAGE) {
	                rendition.language = entry.attributes.LANGUAGE;
	              }

	              if (entry.attributes.URI) {
	                rendition.uri = entry.attributes.URI;
	              }

	              if (entry.attributes['INSTREAM-ID']) {
	                rendition.instreamId = entry.attributes['INSTREAM-ID'];
	              }

	              if (entry.attributes.CHARACTERISTICS) {
	                rendition.characteristics = entry.attributes.CHARACTERISTICS;
	              }

	              if (entry.attributes.FORCED) {
	                rendition.forced = /yes/i.test(entry.attributes.FORCED);
	              } // insert the new rendition


	              mediaGroup[entry.attributes.NAME] = rendition;
	            },
	            discontinuity: function discontinuity() {
	              currentTimeline += 1;
	              currentUri.discontinuity = true;
	              this.manifest.discontinuityStarts.push(uris.length);
	            },
	            'program-date-time': function programDateTime() {
	              if (typeof this.manifest.dateTimeString === 'undefined') {
	                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards
	                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag
	                // to the manifest object
	                // TODO: Consider removing this in future major version
	                this.manifest.dateTimeString = entry.dateTimeString;
	                this.manifest.dateTimeObject = entry.dateTimeObject;
	              }

	              currentUri.dateTimeString = entry.dateTimeString;
	              currentUri.dateTimeObject = entry.dateTimeObject;
	            },
	            targetduration: function targetduration() {
	              if (!isFinite(entry.duration) || entry.duration < 0) {
	                this.trigger('warn', {
	                  message: 'ignoring invalid target duration: ' + entry.duration
	                });
	                return;
	              }

	              this.manifest.targetDuration = entry.duration;
	              setHoldBack.call(this, this.manifest);
	            },
	            start: function start() {
	              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {
	                this.trigger('warn', {
	                  message: 'ignoring start declaration without appropriate attribute list'
	                });
	                return;
	              }

	              this.manifest.start = {
	                timeOffset: entry.attributes['TIME-OFFSET'],
	                precise: entry.attributes.PRECISE
	              };
	            },
	            'cue-out': function cueOut() {
	              currentUri.cueOut = entry.data;
	            },
	            'cue-out-cont': function cueOutCont() {
	              currentUri.cueOutCont = entry.data;
	            },
	            'cue-in': function cueIn() {
	              currentUri.cueIn = entry.data;
	            },
	            'skip': function skip() {
	              this.manifest.skip = camelCaseKeys(entry.attributes);
	              this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);
	            },
	            'part': function part() {
	              var _this2 = this;

	              hasParts = true; // parts are always specifed before a segment

	              var segmentIndex = this.manifest.segments.length;
	              var part = camelCaseKeys(entry.attributes);
	              currentUri.parts = currentUri.parts || [];
	              currentUri.parts.push(part);

	              if (part.byterange) {
	                if (!part.byterange.hasOwnProperty('offset')) {
	                  part.byterange.offset = lastPartByterangeEnd;
	                }

	                lastPartByterangeEnd = part.byterange.offset + part.byterange.length;
	              }

	              var partIndex = currentUri.parts.length - 1;
	              this.warnOnMissingAttributes_("#EXT-X-PART #" + partIndex + " for segment #" + segmentIndex, entry.attributes, ['URI', 'DURATION']);

	              if (this.manifest.renditionReports) {
	                this.manifest.renditionReports.forEach(function (r, i) {
	                  if (!r.hasOwnProperty('lastPart')) {
	                    _this2.trigger('warn', {
	                      message: "#EXT-X-RENDITION-REPORT #" + i + " lacks required attribute(s): LAST-PART"
	                    });
	                  }
	                });
	              }
	            },
	            'server-control': function serverControl() {
	              var attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);

	              if (!attrs.hasOwnProperty('canBlockReload')) {
	                attrs.canBlockReload = false;
	                this.trigger('info', {
	                  message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'
	                });
	              }

	              setHoldBack.call(this, this.manifest);

	              if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {
	                this.trigger('warn', {
	                  message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'
	                });
	              }
	            },
	            'preload-hint': function preloadHint() {
	              // parts are always specifed before a segment
	              var segmentIndex = this.manifest.segments.length;
	              var hint = camelCaseKeys(entry.attributes);
	              var isPart = hint.type && hint.type === 'PART';
	              currentUri.preloadHints = currentUri.preloadHints || [];
	              currentUri.preloadHints.push(hint);

	              if (hint.byterange) {
	                if (!hint.byterange.hasOwnProperty('offset')) {
	                  // use last part byterange end or zero if not a part.
	                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;

	                  if (isPart) {
	                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;
	                  }
	                }
	              }

	              var index = currentUri.preloadHints.length - 1;
	              this.warnOnMissingAttributes_("#EXT-X-PRELOAD-HINT #" + index + " for segment #" + segmentIndex, entry.attributes, ['TYPE', 'URI']);

	              if (!hint.type) {
	                return;
	              } // search through all preload hints except for the current one for
	              // a duplicate type.


	              for (var i = 0; i < currentUri.preloadHints.length - 1; i++) {
	                var otherHint = currentUri.preloadHints[i];

	                if (!otherHint.type) {
	                  continue;
	                }

	                if (otherHint.type === hint.type) {
	                  this.trigger('warn', {
	                    message: "#EXT-X-PRELOAD-HINT #" + index + " for segment #" + segmentIndex + " has the same TYPE " + hint.type + " as preload hint #" + i
	                  });
	                }
	              }
	            },
	            'rendition-report': function renditionReport() {
	              var report = camelCaseKeys(entry.attributes);
	              this.manifest.renditionReports = this.manifest.renditionReports || [];
	              this.manifest.renditionReports.push(report);
	              var index = this.manifest.renditionReports.length - 1;
	              var required = ['LAST-MSN', 'URI'];

	              if (hasParts) {
	                required.push('LAST-PART');
	              }

	              this.warnOnMissingAttributes_("#EXT-X-RENDITION-REPORT #" + index, entry.attributes, required);
	            },
	            'part-inf': function partInf() {
	              this.manifest.partInf = camelCaseKeys(entry.attributes);
	              this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);

	              if (this.manifest.partInf.partTarget) {
	                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;
	              }

	              setHoldBack.call(this, this.manifest);
	            }
	          })[entry.tagType] || noop).call(self);
	        },
	        uri: function uri() {
	          currentUri.uri = entry.uri;
	          uris.push(currentUri); // if no explicit duration was declared, use the target duration

	          if (this.manifest.targetDuration && !('duration' in currentUri)) {
	            this.trigger('warn', {
	              message: 'defaulting segment duration to the target duration'
	            });
	            currentUri.duration = this.manifest.targetDuration;
	          } // annotate with encryption information, if necessary


	          if (_key) {
	            currentUri.key = _key;
	          }

	          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary

	          if (currentMap) {
	            currentUri.map = currentMap;
	          } // reset the last byterange end as it needs to be 0 between parts


	          lastPartByterangeEnd = 0; // prepare for the next URI

	          currentUri = {};
	        },
	        comment: function comment() {// comments are not important for playback
	        },
	        custom: function custom() {
	          // if this is segment-level data attach the output to the segment
	          if (entry.segment) {
	            currentUri.custom = currentUri.custom || {};
	            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object
	          } else {
	            this.manifest.custom = this.manifest.custom || {};
	            this.manifest.custom[entry.customType] = entry.data;
	          }
	        }
	      })[entry.type].call(self);
	    });

	    return _this;
	  }

	  var _proto = Parser.prototype;

	  _proto.warnOnMissingAttributes_ = function warnOnMissingAttributes_(identifier, attributes, required) {
	    var missing = [];
	    required.forEach(function (key) {
	      if (!attributes.hasOwnProperty(key)) {
	        missing.push(key);
	      }
	    });

	    if (missing.length) {
	      this.trigger('warn', {
	        message: identifier + " lacks required attribute(s): " + missing.join(', ')
	      });
	    }
	  }
	  /**
	   * Parse the input string and update the manifest object.
	   *
	   * @param {string} chunk a potentially incomplete portion of the manifest
	   */
	  ;

	  _proto.push = function push(chunk) {
	    this.lineStream.push(chunk);
	  }
	  /**
	   * Flush any remaining input. This can be handy if the last line of an M3U8
	   * manifest did not contain a trailing newline but the file has been
	   * completely received.
	   */
	  ;

	  _proto.end = function end() {
	    // flush any buffered input
	    this.lineStream.push('\n');
	    this.trigger('end');
	  }
	  /**
	   * Add an additional parser for non-standard tags
	   *
	   * @param {Object}   options              a map of options for the added parser
	   * @param {RegExp}   options.expression   a regular expression to match the custom header
	   * @param {string}   options.type         the type to register to the output
	   * @param {Function} [options.dataParser] function to parse the line into an object
	   * @param {boolean}  [options.segment]    should tag data be attached to the segment object
	   */
	  ;

	  _proto.addParser = function addParser(options) {
	    this.parseStream.addParser(options);
	  }
	  /**
	   * Add a custom header mapper
	   *
	   * @param {Object}   options
	   * @param {RegExp}   options.expression   a regular expression to match the custom header
	   * @param {Function} options.map          function to translate tag into a different tag
	   */
	  ;

	  _proto.addTagMapper = function addTagMapper(options) {
	    this.parseStream.addTagMapper(options);
	  };

	  _proto.stringify = function stringify() {
	    return Writer(this.manifest);
	  };

	  return Parser;
	}(Stream);

	exports.LineStream = LineStream;
	exports.ParseStream = ParseStream;
	exports.Parser = Parser;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
